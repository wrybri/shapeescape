<doctype html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Team Brain Train 5</title>
    <!-- JavaScript HTML requirements -->
    <link rel="stylesheet" href="https://code.jquery.com/mobile/1.2.0/jquery.mobile-1.2.0.min.css">
    <script src="https://code.jquery.com/jquery-1.8.2.min.js"></script>
    <script src="https://code.jquery.com/mobile/1.2.0/jquery.mobile-1.2.0.min.js"></script>
	
	<script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.9.22/paper-full.min.js"></script>

	<link rel="stylesheet" type="text/css" media="all" href="css/styles.css">
	<link rel="stylesheet" type="text/css" media="all" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/themes/base/jquery-ui.css">
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.10.3/jquery-ui.min.js"></script>

	<script type="text/javascript" src="paper-full.min.js"></script>
	
</head>
<body>
	
	<div data-role="page" id="menu">
		<canvas id="menuanima" width=3000 height=3000></canvas>
		<div >
			<a href="#play"><img src="pngBtns/PlayBtn.png" class="menubtns" id="playbtn" /></a>
			<a href="#tutorial"><img src="pngBtns/TutorialBtn.png" class="menubtns" id="tutbtn" /></a>
			<a href="#leaderboard"><img src="pngBtns/LBBtn.png" class="menubtns" id="lbbtn" /></a>
			<a href="#options"><img src="pngBtns/OptionsBtn.png" class="menubtns" id="optionsbtn" /></a>
		</div>
	</div>
	
	<div data-role="page" id="play">
		<canvas id = "braingame" width = 3000 height = 3000></canvas>
		<p><span id = "memo">Shape Escape v0.1</span>
		<p><span id = "score"></span>
		<p><span id = "memo2"></span>
		<p><span id = "memo3"></span>
		<p><span id = "memo4"></span>
		<p><span id = "memo5"></span>
		<audio preload="metadata" id="background" onloadeddata="setLowVolume()" autoplay loop> 
		<source src="sound/time.mp3">
		</audio>

		<button onclick="document.getElementById('background').play()">Play Music</button>
		<button onclick="document.getElementById('background').pause()">Pause Music</button>
		<button onclick="document.getElementById('background').pause(); document.getElementById('background').currentTime = 0;">Stop Music</button>
	</div>
	
	<div data-role="page" id="options">
		<a href="#" data-rel="back">Go Back</a>
		<div id="content">
			<div id="bgm">
				Volume: <span id="bgmval">100</span>
			</div>
			<div id="bgmslide"></div>
			
			<div id="sfx">
				Sound Effects: <span id="sfxval">100</span>
			</div>
			<div id="sfxslide"></div>
		</div><!-- end #content -->
		
	</div>
	
	<div data-role="page" id="tutorial">
		<a href="#" data-rel="back">Go Back</a>
	</div>
	
	<div data-role="page" id="leaderboard">
		<a href="#" data-rel="back">Go Back</a>
	</div>



<script type = "text/paperscript" canvas = "braingame">

// Constants
var startAngle = 0;
var endAngle = 2 * Math.PI;
var triRatio = 0.866; // Equilateral triangle ratio of height/base
// Global settings
var canvas = document.getElementById("braingame");
var ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
var start = null;						// Timestamp of first frame
var progress;							// Time elapsed in ms from first frame
var DEBUG = false;						// Debug 1 (mobs info & auto gate-trigger)
var DEBUG2 = false;						// Debug 2 (gate state)
var DEBUG3 = false;						// Debug3 (rules)
var DEBUG4 = false;						// Debug4 (3d mobs array)
var DEBUG5 = false;						// Debug5 (mobPause)
var DEBUG6 = false;						// Debug6 (Paper.js integration)
var memo = document.getElementById("memo");		// Text-box to display debug info
var memo2 = document.getElementById("memo2");		// Text-box#2 to display debug info
var memo3 = document.getElementById("memo3");		// Text-box#3 to display debug info
var memo4 = document.getElementById("memo4");		// Text-box#4 to display debug info
var memo5 = document.getElementById("memo5");		// Text-box#5 to display debug info
var scoreMemo = document.getElementById("score");		// Score box (temporary)
var score = 0;							// User 'score' ie correct choices
var strikes = 0;						// User 'strikes' ie incorrect choices
var maxStrikes = 3;						// Maximum strikes before game over
var level = 1;							// Game 'level' ie round ie wave etc etc etc etc
var timestamp;							// Time in milliseconds from game-start
//Menu Bar Constants
var barWidth = 50;
var barHeight = 60;
var barColor = "#fcef94";				//Fill Color
var barStrokeColor = "#000000";
//var level = 0;
//var score = 0;
//var strikes = 0;
// Mobs constants
var mobs = [];							// Array of active moving objects
var mobCount = 0;							// Number of mob-groups created
var xSpeed = 300; 						// Object X speed in pixels per second
var mobMasterRadius = 25;				// Universal shape half-width
var originX = -mobMasterRadius; 		// X origin for shapes
var originY = canvas.height / 2 + barHeight/2;		// Y origin for shapes
var maxMobs = 3;						// Maximum number of mobs in a group
var minMobs = 1;						// Minimum number mobs in a group
var mobYSpacing = 10;					// Vertical spacing between mobs
// Time in MS (same unit as start/progress vars) for mob to completely traverse screen
var mobTransitTime = (canvas.width - originX + mobMasterRadius) / xSpeed * 1000;
var mobYVariance = 30;					// Pixels of Y oscillation (max)
var mobOscillations = 2.25;				// Number of complete sin oscillations 'wavy' mobs do, ie sin(0 to 2pi)
var mobFrequency = 1.5;					// Seconds between mob-groups
var mobPause = 0;						// 0 = mobs not paused. 1 = paused before rule-change. 2 = paused after
var mobPauseTimestamp = null;			// Timestamp for initiation of a mob-pause
var mobPauseDuration = 3;				// Seconds delay (for new mobs) before level-up
var mobPause2Duration = 2;				// Seconds delay after level-up
var mobStarPoints = 5;					// Number of points stars have
var mobStrokeWidth = 2;					// Stroke width for moving shapes
var mobShapes = 5;						// Number of different types of shapes
var mobFills = ['#ff0000', '#00ff00', '#0000ff', '#ff00ff', '#ffff00'];		// Fill colours
var mobStrokes = ['#cc6666', '#66cc66', '#6666cc', '#cc66cc', '#cccc66'];	// Stroke colours
// Gate constants
var gateState = 0;						// 0 closed, 1 opening, 2 open, 3 closing
var gateSpeed = 0.3;					// Time in seconds it takes for gates to open or close
var gateDelay = 1.0;					// Time in seconds gates stay open before closing
var gateMax = 120/360*2*Math.PI;		// Max angle the gates will open (in radians)
// Length of entire gate-opening
var gateLength = maxMobs * (2 * mobMasterRadius + mobYSpacing) + 3.0 * mobMasterRadius;
var gateWidth = 10;						// Width of gate in pixels
var fenceWidth = 15;					// Width of fence (non-moving)
var gateX = canvas.width - 1.25 * gateLength;	// Gate X position
var gateGap = 4;						// Gap between gate sections, in pixels(when closed)
var gateColour = "#000000";				// Colour of gate as CSS colour
var gateStrokeColour = "#333333";		// Colour of gate outline
var gateTimestamp = null;				// Timestamp for start of gate-open event
var gateDebug2;							// Var used with DEBUG2 to monitor gateState
var gatePrevAngle = 0;					// A hacky way to get the gates to work with Paper.js...
// Rules constants
var rules = [];							// Array of current rules
var rulesMax = 3;						// Max number of rules
var rulesDuration = 10;					// Number of mob-groups the rules will apply to
var rulesY = 2*mobMasterRadius;			// Y position for rules (top)
var rulesX = gateX + gateLength/2 + 2*mobMasterRadius;		// X position for rules (left)
var rulesFontSize = 40;
var rulesFont = "arial";
var rulesNoWidth = 6;					// Line-width for the 'no' symbol
var rulesStrokeWidth = 4;				// Stroke-width for the rules shape
var rulesColour = "red";
var rulesNoSize = 1.5;					// How big the 'no' symbol for rules should be, vs mob-size
var rulesNoColour = "red";				// Colour for 'no' symbol
var rulesShapeColour = "black";			// Colour for rules shapes
var ruleShapePosMax = 1;				// Max number of must-have-this-shape rules
var ruleShapeNegMax = 2;				// Max number of must-not-have-this-shape rules
var ruleColourPosMax = 1;				// Max number of must-have-this-colour rules
var ruleColourNegMax = 2;				// Max number of must-not-have-this-colour rules
// Game Over
var gameOverFontColour = "red";
var gameOverFontSize = 180;				// Font-size in pixels
var gameOverFont = "arial";
var gameOverY = (canvas.height - gameOverFontSize) / 2 + gameOverFontSize;
var gameOverLineColour = "#ff9999";
var gameOverLineWidth = 3;
// Bad decision
var badWords = ["Bad!", "Oops!", "NO!", "OMG", "Huh", "Stahp", "Ugh", "Oh no!"];
var badCurrentWord = "bad";				// The current active badword
var badTimestamp;						// Timestamp for start of 'bad' event
var badFlag = false;					// Boolean to indicate an active 'bad' event
var badX;								// Bad X 
var badY;								// Bad Y 
var badFont = "arial";
var badFontSizeStart = 50;				// Initial bad font size
var badFontSizeEnd = 100;				// Ending bad font size
var badDuration = 0.75;					// "Bad" event duration in seconds
var badFontColour = "255,0,0";			// Font colour in comma-separated RGB
var badPaperColour = '#ff0000';			// Font colour for Paper.js
var badPaper;							// Paper.js obj for 'bad' text
// good decision
var goodWords = ["Good!", "Boss!", "Sweet", "Great!", "Nice!", "OK!", 
	"Killer!", "Woot!", "Aaight", "Wow!", "Ooh", "Lovely!", "Superb", 
	"Tops!", "Rockin'", "Hoo-ah!", "Yes!", "Yeah!", "A+", "Bueno!", "Sugoi!"];
var goodCurrentWord = "good";			// The current active goodword
var goodTimestamp;						// Timestamp for start of 'good' event
var goodFlag = false;					// Boolean to indicate an active 'good' event
var goodX;								// good X 
var goodY;								// good Y 
var goodFont = "arial";
var goodFontSizeStart = 40;				// Initial good font size
var goodFontSizeEnd = 80;				// Ending good font size
var goodDuration = 0.75;				// "good" event duration in seconds
var goodFontColour = "0,255,0";			// Font colour in comma-separated RGB
var goodPaperColour = '#00ff00';		// Font colour for Paper.js
var goodPaper;							// Paper.js obj for 'good' text
var gameEnd = false;

//VOLUME SLIDER
$(function(){
  $('#bgmslide').slider({ 
    max: 100,
    min: 0,
    value: 100,
    slide: function(e,ui) {
      $('#bgmval').html(ui.value);	  //displays the current value as text to span id currentval
		background.volume = ui.value * 0.01;	//adjusts volume
	}
  });
  $('#sfxslide').slider({ 
    max: 100,
    min: 0,
    value: 100,
    slide: function(e,ui) {
      $('#sfxval').html(ui.value);	  //displays the current value as text to span id currentval
		snd_good.volume = ui.value * 0.01;	//adjusts volume
		snd_bad.volume = ui.value * 0.01;	//adjusts volume
		snd_gameover.volume = ui.value * 0.01;	//adjusts volume
	}
  });
});


//Canvas resizing
/*(function() {
 
	// Start listening to resize events and
	// draw canvas.
	initialize();

	function initialize() {
		// Register an event listener to
		// call the resizeCanvas() function each time 
		// the window is resized.
		window.addEventListener('resize', resizeCanvas, false);
		
		resizeCanvas();
	}				

	// Runs each time the DOM window resize event fires.
	// Resets the canvas dimensions to match window,
	// then draws the new borders accordingly.
	function resizeCanvas() {
		//if(strikes < maxStrikes){
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
			//window.requestAnimationFrame(dFrame);
		//}
	}
})();*/
			
//Status Bar

var barGradient = {
		gradient: {
			stops: [["#ffffff", 0.01], ["#f1f1f1", 0.2], ["#555555", 1]],
			radial: false
		},
		origin: [0, 0],
		destination: [0, 50]
	};
	
new Path.Rectangle({
	point: [0,0],
	size: [canvas.width, barHeight],
	strokeColor: barStrokeColor,
	fillColor: barGradient			
});

var levelText = new PointText({
    point: [ 50, (barHeight + 12.5)/2],
    content: 'Level: ' + level,
    fillColor: 'black',
    fontFamily: 'Arial',
    fontWeight: 'bold',
    fontSize: 25
});

var scoreText = new PointText({
    point: [ 300, (barHeight + 12.5)/2],
    content: 'Score: ' + score,
    fillColor: 'black',
    fontFamily: 'Arial',
    fontWeight: 'bold',
    fontSize: 25
});

var strikesText = new PointText({
    point: [ 550, (barHeight + 12.5)/2],
    content: 'Strikes: ' + strikes,
    fillColor: 'black',
    fontFamily: 'Arial',
    fontWeight: 'bold',
    fontSize: 25
});
// Paper.js - Draw immobile fence pieces
new Path.Rectangle({
	point: [gateX - fenceWidth/2, 0 + barHeight],
	size: [fenceWidth, (canvas.height - gateLength) / 2 ],
	strokeColor: gateStrokeColour,
	fillColor: gateColour
});
new Path.Rectangle({
	point: [gateX - fenceWidth/2, canvas.height - (canvas.height - gateLength) / 2],
	size: [fenceWidth, (canvas.height - gateLength) / 2],
	strokeColor: gateStrokeColour,
	fillColor: gateColour
});
// Paper.js - Draw movable gate pieces in initial positions
var topHinge = new Point(gateX + gateWidth/2, (canvas.height - gateLength) / 2 + barHeight);
var bottomHinge = new Point(gateX + gateWidth/2, canvas.height - (canvas.height - gateLength) / 2);
// Top
var topGate = new Path.Rectangle({
	from: topHinge,
	to: new Point(gateX - gateWidth/2, topHinge.y + (gateLength - gateGap) / 2),
	strokeColor: gateStrokeColour,
	fillColor: gateColour,
	center: topHinge
});
// Bottom
var bottomGate = new Path.Rectangle({
	from: bottomHinge,
	to: new Point(gateX - gateWidth/2, bottomHinge.y - (gateLength - gateGap) / 2),
	strokeColor: gateStrokeColour,
	fillColor: gateColour,
	center: bottomHinge
});
// Draw 'RULES'
new PointText({
	point: [rulesX, rulesY + barHeight],
	content: 'RULES',
	fontSize: rulesFontSize,
	fontFamily: rulesFont,
	fillColor: rulesColour
});
// Handle Paper.js click events
function onMouseDown(event) {
	openGate();
}
// onFrame draws one complete frame
function onFrame(event) {
	if (strikes < maxStrikes) {
		timestamp = event.time * 1000;
	}
	if (!start) start = timestamp;
	progress = timestamp - start;
	// Stop new mob-creation for a few seconds before a new rule is introduced
	if (mobPause == 0 && Math.floor(mobCount / rulesDuration) + 1 != level) {
		mobPause = 1;
		if (DEBUG5) memo5.innerHTML += "mobPause = 1<br>\n";
	}
	
	// Restart mob creation after a mob-pause
	if (mobPause == 2 && progress - mobPauseTimestamp > mobPause2Duration * 1000) {
		mobPause = 0;
		if (DEBUG5) memo5.innerHTML += "mobPause = 0<br>\n";
		mobPauseTimestamp = null;
	}
	
	// Create new mobs
	if (mobPause == 0 && (mobs.length == 0 || 
			(mobs.length > 0 && progress - mobs[mobs.length-1][0][6] > mobFrequency * 1000))) {
		if (DEBUG4) memo4.innerHTML = "Creating new mobgroup:\n<br>";
		var r;
		var g;
		var b;
		var fillStyle;
		var strokeStyle;
		var numNewMobs = Math.floor(Math.random() * (maxMobs - minMobs + 1)) + minMobs;
		// mobGroupHeight is the distance from the centre of top mob to centre of bottom mob
		var mobGroupHeight = (numNewMobs - 1) * (mobYSpacing + 2 * mobMasterRadius);
		// memo.innerHTML = "";
		var mobGroup = [];			// Array of mobs for insertion into master 3d mobs array
		mobCount++;
		
		for (var looper = 0 ; looper < numNewMobs ; looper++ ) {
			if (DEBUG4) memo4.innerHTML += "Mob " + looper + "\n<br>";
			var mobShapeType = Math.floor(Math.random() * mobShapes);
			var originYInit = originY - mobGroupHeight / 2 + looper * (2 * mobMasterRadius + mobYSpacing);
			//Generate colours for fill style and line style
			/*
			r = Math.floor(Math.random() * 2);
			g = Math.floor(Math.random() * 2);
			b = Math.floor(Math.random() * 2);			
			fillStyle = "#" + (r?"ff":"00") + (g?"ff":"00") + (b?"ff":"00");
			strokeStyle = "#" + (r?"cc":"66") + (g?"cc":"66") + (b?"cc":"66");
			// Make pure-white into an off-white
			if (fillStyle == "#ffffff") {
				fillStyle = "#eeeeee";
				strokeStyle = "#cccccc";
			}
			*/
			var mobColourIndex = Math.floor(Math.random() * mobFills.length);
			fillStyle = mobFills[mobColourIndex];
			strokeStyle = mobStrokes[mobColourIndex];
			
			// Paper.JS
			if (mobShapeType == 0) { 	// Circle
				var mobPaper = new Path.Circle({
					center: [originX, originYInit],
					radius: mobMasterRadius,
					strokeColor: strokeStyle,
					strokeWidth: mobStrokeWidth
				});
			} else if (mobShapeType == 1) { // Triangle
				var mobPaper = new Path.RegularPolygon({
					center: [originX, originYInit],
					sides: 3,
					radius: mobMasterRadius / Math.cos(Math.PI / 6),
					fillColor: fillStyle,
					strokeColor: strokeStyle,
					strokeWidth: mobStrokeWidth
				});
			} else if (mobShapeType == 2) { // Square
				var mobPaper = new Path.Rectangle({
					rectangle: new Rectangle(originX - mobMasterRadius, originYInit - mobMasterRadius, 2 * mobMasterRadius, 2 * mobMasterRadius),
					center: [originX, originYInit],
					fillColor: fillStyle,
					strokeColor: strokeStyle,
					strokeWidth: mobStrokeWidth
				});
			} else if (mobShapeType == 3) { // Pentagon
				var mobPaper = new Path.RegularPolygon({
					center: [originX, originYInit],
					sides: 5,
					radius: mobMasterRadius,
					fillColor: fillStyle,
					strokeColor: strokeStyle,
					strokeWidth: mobStrokeWidth
				});
			} else if (mobShapeType == 4) { // Star
				var mobPaper = new Path.Star({
					center: [originX, originYInit],
					radius1: mobMasterRadius,
					radius2: mobMasterRadius/2,
					points: mobStarPoints,
					fillColor: fillStyle,
					strokeColor: strokeStyle,
					strokeWidth: mobStrokeWidth
				});
			}
			
			// Set-up colour gradient on new shape object
			mobPaper.fillColor = {
					gradient: {
						stops: [[fillStyle, 0.05], [fillStyle, 0.2], [strokeStyle, 1]],
						radial: true
					},
					origin: mobPaper.position,
					destination: mobPaper.bounds.rightCenter
				};
				
			// Insert new mob into array (1 shape)
			mobGroup.push([originX, originYInit, mobShapeType, mobMasterRadius, fillStyle, strokeStyle, progress, mobPaper]);
			
		}
		// Insert new mob group into master mobs array
		if (DEBUG4) memo4.innerHTML += "mobGroup.length: " + mobGroup.length + "\n<br>";
		mobs.push(mobGroup);
		if (DEBUG4) memo4.innerHTML += "mobs.length: " + mobs.length + "\n<br>";
		
		// Display mob debug info
		if (DEBUG == true) {
			memo.innerHTML = "<br>\nActive mobs:<br>\n";
			for (var p = 0 ; p < mobs.length ; p++ ) {
				for (var q = 0 ; q < mobs[p].length ; q++ ) {
					for (var r = 0 ; r < mobs[p][q].length ; r++) {
						memo.innerHTML += mobs[p][q][r] + "  ";
					}
				}
				memo.innerHTML += "<br>\n";
			}
		}
	}
	// Draw the mobs
	for (var looper = 0 ; looper < mobs.length ; looper++) {
		for (var looper2 = 0 ; looper2 < mobs[looper].length ; looper2++) {
			var tempMob = mobs[looper][looper2];
			if (DEBUG4) memo4.innerHTML = "l1: " + looper + "  l2: " + looper2 + " tempMob: " + tempMob + "\n<br>";
			
			var mobX = tempMob[0] + (progress - tempMob[6]) / 1000 * xSpeed;  // X refresh		
			var mobY = tempMob[1] + Math.sin((progress - tempMob[6]) / mobTransitTime * endAngle * mobOscillations) * mobYVariance;
			// Paper.js
			var mobPaperObj = tempMob[7];
			mobPaperObj.position.x = mobX;
			mobPaperObj.position.y = mobY;
		}
	}
	var gateAngle = 0;
	//DEBUG2
	if (DEBUG2) {
		if (gateDebug2 == null) gateDebug2 = gateState;
		if (gateDebug2 != gateState) {
			memo2.innerHTML += "gateState changed to " + gateState + "<br>\n";
			gateDebug2 = gateState;
		}
	}
	
	switch (gateState) {
		case 0:		// Closed
			gateAngle = 0;
		break;
		
		case 1:		// Opening
			if (gateTimestamp == null || gateTimestamp == 0) {
				gateTimestamp = progress;
				if (DEBUG) memo2.innerHTML = "Gate timestamp: " + gateTimestamp;
			}
			gateAngle = (progress - gateTimestamp) / (gateSpeed * 1000) * gateMax;
			if (gateAngle > gateMax) {
				gateAngle = gateMax;
				gateState = 2;
			}
		break;
		
		case 2:		// Fully open
			gateAngle = gateMax;
			if (progress - gateTimestamp > (gateSpeed + gateDelay) * 1000) {
				gateState = 3;
			}
		break;
		
		case 3:		// Closing
			gateAngle = (gateSpeed * 1000 -(progress - (gateTimestamp + (gateSpeed + gateDelay) * 1000)))
				/ (gateSpeed * 1000) * gateMax;
			if (progress - gateTimestamp > (2 * gateSpeed + gateDelay) * 1000) {
				gateAngle = 0;
				gateState = 0;
				gateTimestamp = 0;
			}
		break;
	}
	// Paper.js - a hacky way to make the old gate logic work with Paper
	if (gateAngle != gatePrevAngle) {
		var paperGateAngle = gateAngle - gatePrevAngle;
		gatePrevAngle = gateAngle;
	} else {
		var paperGateAngle = 0;
	}
	
	// Paper.js - Set rotation for gates
	topGate.rotate((-paperGateAngle / (2 * Math.PI)) * 360, topHinge);
	bottomGate.rotate((paperGateAngle / (2 * Math.PI)) * 360, bottomHinge);
	
	if (DEBUG3) {
	memo3.innerHTML = "mobCount = " + mobCount + "<br>\n";
	}
	// Add a new rule
	// [0] rule type 0=shape 1=colour  [1] 0=regular rule 1=NOT rule  [2] shape-type (0-2 just like mobs array)
	// [3] colour ie #ff0000  [4] Array of Paper.js shape objects (1 shape and optionally 1 'not' symbol)
	if (rules.length == 0 || (mobPause == 1 && mobs.length == 0)) {
		if (DEBUG6) console.log('Add a new rule');
		// Update level
		level = Math.floor(mobCount / rulesDuration) + 1;
		levelScore();	// Refresh level & score
		if (rules.length > 0 ) {
			mobPauseTimestamp = progress;
			mobPause = 2;
			if (DEBUG5) memo5.innerHTML += "mobPause = 2<br>\n";
			}
		if (rules.length == rulesMax) {
			newRule();			// Doing it in this order prevents the same rule from being re-inserted
			paperDealloc(rules[0][4]);
			rules.shift();		// Delete the oldest rule
		} else {
			newRule();
		}
		if (DEBUG3) {
		memo3.innerHTML += "Rule added<br>\n";
		memo3.innerHTML += rules.length + " rules.<br>\n";
		}
		if (rules.length >= 2) { // Increase min mobgroup size when there's more than 1 rule
			minMobs = 2;
		}
		// Paper.js - redraw rules
		drawRuleSetPaper();
	}
	
	// Draw any active 'bad' events
	if (badFlag) {
		ruleBad();
	}
	
		// Draw any active 'bad' events
	if (goodFlag) {
		ruleGood();
	}
			
	// Remove mobs that make it past gate
	if (mobs.length > 0 && timestamp - mobs[0][0][6] > (rulesX + mobMasterRadius) / xSpeed * 1000) {
		if (checkRule(mobs[0])) {
			ruleGood(rulesX, canvas.height/2);
		} else {
			ruleBad(rulesX, canvas.height/2);
		}
		// Paper.js - remove mob group from scene
		paperMobDealloc(mobs[0]);
		
		mobs.shift();
	}
	// Kill mobs that hit closed gate
	while ( mobs.length > 0
		&& timestamp - mobs[0][0][6] > (gateX) / xSpeed * 1000 
		&& timestamp - mobs[0][0][6] < (gateX + mobMasterRadius) / xSpeed * 1000
		&&(gateState == 0 || gateState == 3)) {
		if (!checkRule(mobs[0])) {
			ruleGood(gateX, canvas.height/2);
		} else {
			ruleBad(gateX, canvas.height/2);
		}
		// Paper.js - remove mob group from scene
		paperMobDealloc(mobs[0]);
		
		mobs.shift();
	}
	if (strikes < maxStrikes) {
		// gameOver(); 	// To test game-over text quickly
		// window.requestAnimationFrame(dFrame);
	} else {
		gameOver();
	}
}
// Paper.js needs its own "draw rules" functions b/c it doesn't need to draw them per frame
function drawRuleSetPaper() {
	if (DEBUG6) console.log('drawRuleSetPaper()');
	var rulesXcentre = rulesX + (canvas.width - rulesX) / 2;
	var rulesYstart = rulesY + rulesFontSize + mobMasterRadius * rulesNoSize + mobYSpacing + barHeight/2
	
	// Clear out the old rule shapes
	for (var i = 0 ; i < rules.length ; i++) {
		if (rules[i][4].length > 0) {
			paperDealloc(rules[i][4]);
			rules[i][4] = [];
		}
	}
	
	for (var looper = 0 ; looper < rules.length ; looper++) {
		if (rules[looper][0] == 0) {	// Shape-rule
			rules[looper][4].push(drawPaperRule(rules[looper][2], rulesXcentre, rulesYstart + looper * (2 * mobMasterRadius * rulesNoSize + mobYSpacing)));
		} else {	// Colour-rule
			var rulesRect = new Path.Rectangle({
				point: [rulesX, rulesYstart - mobMasterRadius * rulesNoSize + looper * (2 * mobMasterRadius * rulesNoSize + mobYSpacing)],
				size: [canvas.width - rulesX, 2 * mobMasterRadius * rulesNoSize],
				fillColor: rules[looper][3]
			});
			rulesRect.sendToBack();
			rules[looper][4].push(rulesRect);
		}
		if (rules[looper][1] == 1) { 	// A reverse (Not) rule
			var newNo = drawNoPaper(rulesXcentre, rulesYstart + looper * (2 * mobMasterRadius * rulesNoSize + mobYSpacing),
				rules[looper][3] == "#ff0000" && rules[looper][0] == 1?"#ffffff":rulesNoColour);
			newNo.moveAbove(rules[looper][4][0]);
			rules[looper][4].push(newNo);
		}
	}
		if (DEBUG6) console.log('drawRuleSetPaper() - bottom');
}
// Paper.js - function to remove mob group from scene
function paperMobDealloc(deadGroup) {
	if (DEBUG6) console.log('paperMobDealloc()');
	for (var i = 0 ; i < deadGroup.length ; i++) {
		deadGroup[i][7].remove();
	}
}
// Paper.js - generic function to remove an array of objects from scene
function paperDealloc(deadGroup) {
	if (DEBUG6) console.log('paperDealloc()');
	for (var i = 0 ; i < deadGroup.length ; i++) {
		deadGroup[i].remove();
	}
}
// Return a random colour (CMYK RGB or White)
function randStyle() {
	var r = Math.floor(Math.random() * 2);
	var g = Math.floor(Math.random() * 2);
	var b = Math.floor(Math.random() * 2);
	
	var fillStyle = "#" + (r?"ff":"00") + (g?"ff":"00") + (b?"ff":"00");
	var strokeStyle = "#" + (r?"ff":"33") + (g?"ff":"33") + (b?"ff":"33");
	
	if (fillStyle == "#ffffff") {
		fillStyle = "#eeeeee";
	}
	
	return fillStyle;
}
function openGate() {
	switch(gateState) {
	case 0:
		gateState = 1;
		break;
	case 1:
		// No action required
		break;
	case 2:
		// If gate is already open, reset timer 
		// gateTimestamp += ((progress - gateTimestamp) - gateSpeed * 1000);
		gateTimestamp = progress;
		if(DEBUG2)memo2.innerHTML += "GATE STAY-OPEN<br>\n";
		break;
	case 3:
		// If gate is closing, reverse direction and start opening
		gateTimestamp += (progress - gateTimestamp) - ((2 * gateSpeed + gateDelay) * 1000 - (progress - gateTimestamp));
		gateState = 1;
		if(DEBUG2)memo2.innerHTML += "GATE REOPEN<br>\n";
	
	}
}
// Paper.js - Draw a 'No' over a rule
function drawNoPaper(noX, noY, noColour) {
	if (DEBUG6) console.log('drawNoPaper()');
	var noLineOffset = Math.sqrt(Math.pow(rulesNoSize * mobMasterRadius, 2) / 2);
	var noCircle = new Path.Circle({
		center: [noX, noY],
		radius: rulesNoSize * mobMasterRadius
	});
	var noLine = new Path.Line({
		from: [noX - noLineOffset, noY + noLineOffset],
		to: [noX + noLineOffset, noY - noLineOffset]
	});
	noCompound = new CompoundPath({
		strokeColor: noColour,
		strokeWidth: rulesNoWidth
	});
	noCompound.addChild(noCircle);
	noCompound.addChild(noLine);
	return noCompound;
}
// Paper.js - Separate rule-drawing function as it does not need to be drawn each frame
function drawPaperRule(rType, rX, rY) {
	if (DEBUG6) console.log('drawPaperRule()');
	switch (rType) { 
		case 0: // Circle
		var mobPaper = new Path.Circle({
				center: [rX, rY],
				radius: mobMasterRadius,
				strokeColor: rulesShapeColour,
				strokeWidth: rulesStrokeWidth
				});
		break;
		
		case 1: // Triangle
		// Paper.js
		var mobPaper = new Path.RegularPolygon({
			center: [rX, rY],
			sides: 3,
			radius: mobMasterRadius / Math.cos(Math.PI / 6),
			strokeColor: rulesShapeColour,
			strokeWidth: rulesStrokeWidth
		});
		break;
		
		case 2: // Square
		// Paper.js
		var mobPaper = new Path.Rectangle(new Rectangle(rX - mobMasterRadius, rY - mobMasterRadius, 2 * mobMasterRadius, 2 * mobMasterRadius));
				mobPaper.strokeColor = rulesShapeColour;	
				mobPaper.strokeWidth = rulesStrokeWidth;
		break;
		
		case 3: // Pentagon
			var mobPaper = new Path.RegularPolygon({
				center: [rX, rY],
				sides: 5,
				radius: mobMasterRadius,
				strokeColor: rulesShapeColour,
				strokeWidth: rulesStrokeWidth
			});
		break;
		
		case 4: // Star
			var mobPaper = new Path.Star({
				center: [rX, rY],
				radius1: mobMasterRadius,
				radius2: mobMasterRadius/2,
				points: mobStarPoints,
				strokeColor: rulesShapeColour,
				strokeWidth: rulesStrokeWidth
			});
		break;
	}
	mobPaper.sendToBack();
	return mobPaper;
}
function checkRule(deadGroup) {
	var ruleFlags = new Array(rules.length);
	
	// Loop through all rule/mob combinations for the passed mob-group
	for (var rlooper = 0 ; rlooper < rules.length ; rlooper++) {
		for (var mlooper = 0 ; mlooper < deadGroup.length ; mlooper++ ) {
			if (rules[rlooper][1] == 0) {								// "Must-Have" rule
				if (rules[rlooper][0] == 0) {  		// Shape rule
					if (rules[rlooper][2] == deadGroup[mlooper][2]) {
						ruleFlags[rlooper] = true;
					}
				} else if (rules[rlooper][0] == 1) {	// Colour rule
					if (rules[rlooper][3] == deadGroup[mlooper][4]) {
						ruleFlags[rlooper] = true;
					}
				}
			} else {													// "NOT" rule
				if (rules[rlooper][0] == 0) {  		// Shape rule
					if (rules[rlooper][2] == deadGroup[mlooper][2]) {
						return false;
					}
				} else if (rules[rlooper][0] == 1) {	// Colour rule
					if (rules[rlooper][3] == deadGroup[mlooper][4]) {
						return false;
					}
				}
			}
		}
	}
	// Check to see if all "Must-Have" rules were met
	for (var looper = 0 ; looper < ruleFlags.length ; looper++ ) {
		if (ruleFlags[looper] != true && rules[looper][1] == 0) {
			return false;
		}
	}
	return true;	
}
// Draw an animated "good" message on screen for misses
function ruleGood(bX, bY) {
	levelScore();
	var snd_good = new Audio("sound/chaching.mp3"); // hit sound
	if (goodFlag == false) {
		score++;
		goodFlag = true;
		goodTimestamp = progress;
		goodX = bX;
		goodY = bY;
		goodCurrentWord = goodWords[Math.floor(Math.random() * goodWords.length)];
		// Paper.js - create PointText object for text event
		goodPaper = new PointText(new Point(bX, bY));
		goodPaper.content = goodCurrentWord;
		goodPaper.fontSize = goodFontSizeStart;
		goodPaper.fontFamily = goodFont;
		goodPaper.fillColor = goodPaperColour;
		snd_good.play(); //"Good" choices
		
		// George - put your sound-effect code here for "Good" choices
		// meh.
		
	}
	
	if (arguments.length == 0) {
		bX = goodX;
		bY = goodY
	}
	
	if (goodFlag && progress - goodTimestamp < goodDuration * 1000) {
		var goodFontSize = Math.floor((progress - goodTimestamp) / (goodDuration * 1000) 
		* (goodFontSizeEnd - goodFontSizeStart) + goodFontSizeStart);
		var goodAlpha = (goodDuration * 1000 - (progress - goodTimestamp)) / (goodDuration * 1000);
		
		// Paper.js - scale & alpha font object
		goodPaper.scaling = goodFontSize / goodFontSizeStart;
		goodPaper.opacity =  goodAlpha;
	} else if (goodFlag && progress - goodTimestamp > goodDuration * 1000) {
		goodFlag = false;
		goodPaper.remove();
	}
}
// Draw an animated "bad" message on screen for misses
function ruleBad(bX, bY) {
	levelScore();
	var snd_bad = new Audio("sound/doh.mp3"); //miss sound
	//scoreMemo.innerHTML += "Incorrect!!!<br>\n";
	if (badFlag == false) {
		strikes++;
		badFlag = true;
		badTimestamp = progress;
		badX = bX;
		badY = bY;
		badCurrentWord = badWords[Math.floor(Math.random() * badWords.length)];
		// Paper.js - create PointText object for text event
		badPaper = new PointText(new Point(bX, bY));
		badPaper.content = badCurrentWord;
		badPaper.fontSize = badFontSizeStart;
		badPaper.fontFamily = badFont;
		badPaper.fillColor = badPaperColour;
		snd_bad.play(); //"Bad" choices
		
		// George - put your sound-effect code here for "Bad" choices
		
	}
	
	if (arguments.length == 0) {
		bX = badX;
		bY = badY
	}
	
	if (badFlag && progress - badTimestamp < badDuration * 1000) {
		var badFontSize = Math.floor((progress - badTimestamp) / (badDuration * 1000) 
		* (badFontSizeEnd - badFontSizeStart) + badFontSizeStart);
		var badAlpha = (badDuration * 1000 - (progress - badTimestamp)) / (badDuration * 1000);
		// Paper.js - scale & alpha font object
		badPaper.scaling = badFontSize / badFontSizeStart;
		badPaper.opacity =  badAlpha;
	} else if (badFlag && progress - badTimestamp > badDuration * 1000) {
		badFlag = false;
		badPaper.remove();
	}
}
function gameOver() {
	levelScore();
	var snd_gameover = new Audio("sound/disappointed.mp3");  //game over sound
	var gameOverText = new PointText({
		point: [0, gameOverY],
		content: 'Game Over',
		fontSize: gameOverFontSize,
		fontFamily: gameOverFont,
		fillColor: gameOverFontColour,
		strokeColor: gameOverLineColour,
		strokeWidth: gameOverLineWidth
	});
	if(gameEnd == false){
			snd_gameover.play();//game over sound
			gameEnd = true;
		}
	document.getElementById('background').pause();
	document.getElementById('background').currentTime = 0; //stops the music
	
	gameOverText.point.x = (canvas.width - gameOverText.bounds.width) / 2;
}
function levelScore() {
levelText.remove();
levelText = new PointText({
    point: [ 50, (barHeight + 12.5)/2],
    content: 'Level: ' + level,
    fillColor: 'black',
    fontFamily: 'Arial',
    fontWeight: 'bold',
    fontSize: 25
});
scoreText.remove();
scoreText = new PointText({
    point: [ 300, (barHeight + 12.5)/2],
    content: 'Score: ' + score,
    fillColor: 'black',
    fontFamily: 'Arial',
    fontWeight: 'bold',
    fontSize: 25
});
strikesText.remove();
strikesText = new PointText({
    point: [ 550, (barHeight + 12.5)/2],
    content: 'Strikes: ' + strikes,
    fillColor: 'black',
    fontFamily: 'Arial',
    fontWeight: 'bold',
    fontSize: 25
});
}
function newRule() {
	// Count up numbers of existing rule-types
	var shapePos = 0;
	var shapeNeg = 0;
	var colourPos = 0;
	var colourNeg = 0;
	for (var looper = 0 ; looper < rules.length ; looper++ ) {
		if (rules[looper][0] == 0) { 	// Shape rule
			if (rules[looper][1] == 0) { 	// Must-Have (positive) rule
				shapePos++;
			} else {						// NOT (negative) rule
				shapeNeg++;
			}
		} else {		// Colour rule
			if (rules[looper][1] == 0) { 	// Must-Have (positive) rule
				colourPos++;
			} else {						// NOT (negative) rule
				colourNeg++;
			}
		}
	}
	
	do {
	// Generate a new random rule
	var nRule = [Math.floor(Math.random() * 2), Math.floor(Math.random() * 2),Math.floor(Math.random() * mobShapes), mobFills[Math.floor(Math.random() * mobFills.length)], []];
	// If the new rule exceeds any of the rule-type maximums, re-roll it
	if (nRule[0] == 0 && nRule[1] == 0 && shapePos == ruleShapePosMax) continue;
	if (nRule[0] == 0 && nRule[1] == 1 && shapeNeg == ruleShapeNegMax) continue;
	if (nRule[0] == 1 && nRule[1] == 0 && colourPos == ruleColourPosMax) continue;
	if (nRule[0] == 1 && nRule[1] == 1 && colourNeg == ruleColourNegMax) continue;
	
	// Rule is not duplicate
	if (checkRuleDupe(nRule)) continue;
	// Rule does not contradict another rule
	if (checkRuleContradiction(nRule)) continue;
	
	rules.push(nRule);
	return;
	} while (1);
}
function checkRuleDupe(nR) {
	for (var looper = 0 ; looper < rules.length ; looper++) {
		if (nR[0] == rules[looper][0] && nR[1] == rules[looper][1]) {		// Type and polarity match
			if (nR[0] == 0 && nR[2] == rules[looper][2]) return true;		// Duplicate shape rule
			if (nR[0] == 1 && nR[3] == rules[looper][3]) return true;		// Duplicate colour rule
		}
	}
	return false;
}
// Fun fact: This function is identical to checkRuleDupe except for a single == becomes a !=
function checkRuleContradiction(nR) {
	for (var looper = 0 ; looper < rules.length ; looper++) {
		if (nR[0] == rules[looper][0] && nR[1] != rules[looper][1]) {		// Same type but opposite polarity
			if (nR[0] == 0 && nR[2] == rules[looper][2]) return true;		// Contradicting shape rule
			if (nR[0] == 1 && nR[3] == rules[looper][3]) return true;		// Contradicting colour rule
		}
	}
	return false;
}

function setLowVolume() {
    var myAudio = document.getElementById("background");  
    myAudio.volume = 1.0; //Changed this to 0.5 or 50% volume since the function is called Set Half Volume ;)
}

</script>
<!-- main menu script-->
<script type = "text/paperscript" canvas = "menuanima">
//button positioning
	var playbutton = document.getElementById('playbtn');
	playbutton.style.position = "absolute";
	playbutton.style.left = window.innerWidth / 2 - 149.5;
	playbutton.style.top = window.innerHeight / 2 - 48.5;
	var tutbutton = document.getElementById('tutbtn');
	tutbutton.style.position = "absolute";
	tutbutton.style.left = window.innerWidth / 2 - 127.5;
	tutbutton.style.top = window.innerHeight / 2 + 51.5;
	var lbbutton = document.getElementById('lbbtn');
	lbbutton.style.position = "absolute";
	lbbutton.style.left = window.innerWidth / 2 - 127.5;
	lbbutton.style.top = window.innerHeight / 2 + 135.5;
	var optnbutton = document.getElementById('optionsbtn');
	optnbutton.style.position = "absolute";
	optnbutton.style.left = window.innerWidth / 2 - 40;
	optnbutton.style.top = window.innerHeight / 2 + 219.5;
	
	//button hover functions
	$(function() {
		$("img.menubtns")
			.mouseover(function() { 
				var src = $(this).attr("src").match(/[^\.]+/) + "Over.png";
				$(this).attr("src", src);
			})
			.mouseout(function() {
				var src = $(this).attr("src").replace("Over.png", ".png");
				$(this).attr("src", src);
			});
	});
	
	//main menu resizing
	var canvas = document.getElementById("menuanima");
	var ctx = canvas.getContext('2d');
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	
	//document.getElementById("menuanima").style.background = 'white';
	// The amount of circles we want to make:
	var count = canvas.width/10;

	// Create a symbol, which we will use to place instances of later:
	var pathCircle = new Path.Circle({
		center: [0, 0],
		radius: 40,
		fillColor: 'black',
		strokeColor: 'grey'
	});
	var pathSquare = new Path.Rectangle({
		point: [0, 0],
		size: [35, 35],
		fillColor: 'black',
		strokeColor: 'grey'
	});
	var pathTriangle = new Path.RegularPolygon({
		center: [0, 0],
		sides: 3,
		radius: 40,
		fillColor: 'black',
		strokeColor: 'grey'
	});
	var pathPentagon = new Path.RegularPolygon({
		center: [0, 0],
		sides: 5,
		radius: 40,
		fillColor: 'black',
		strokeColor: 'grey'
	});
	var pathStar = new Path.Star({
		center: [50, 50],
		points: 5,
		radius1: 40,
		radius2: -40,
		fillColor: 'black',
		strokeColor: 'grey'
	});
	
	//var symbol = new Symbol(path);

	// Place the instances of the symbol:
	for (var i = 0; i < count; i++) {
		if(i % 2 == 0){
			var symbol = new Symbol(pathCircle);
		}
		if(i % 5 == 0){
			var symbol = new Symbol(pathSquare);
		}
		if(i % 7 == 0){
			var symbol = new Symbol(pathTriangle);
		}
		if(i % 4 == 0){
			var symbol = new Symbol(pathPentagon);
		}
		if(i % 9 == 0){
			var symbol = new Symbol(pathStar);
		}
		// The center position is a random point in the view:
		var center = Point.random() * screen.width;
		var placedSymbol = symbol.place(center);
		placedSymbol.scale(i / count);
	}

	// The onFrame function is called up to 60 times a second:
	function onFrame(event) {
		// Run through the active layer's children list and change
		// the position of the placed symbols:
		for (var i = 0; i < count; i++) {
			var item = project.activeLayer.children[i];
			
			// Move the item 1/20th of its width to the right. This way
			// larger circles move faster than smaller circles:
			item.position.x += item.bounds.width / 100;

			// If the item has left the view on the right, move it back
			// to the left:
			if (item.bounds.left > view.size.width) {
				item.position.x = -item.bounds.width;
			}
		}
	}
	
	
</script>

</body>