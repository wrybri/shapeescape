
<doctype html>
<head>
<title>Team Brain Train 5</title>
</head>
<body>
<canvas id = "braingame" width = 1000 height = 400 onclick = "openGate()"></canvas>
<p><span id = "memo">Shape Escape v0.1</span>
<p><span id = "score"></span>
<p><span id = "memo2"></span>
<p><span id = "memo3"></span>
<p><span id = "memo4"></span>
<p><span id = "memo5"></span>
<script>
// Constants
var startAngle = 0;
var endAngle = 2 * Math.PI;
var triRatio = 0.866; // Equilateral triangle ratio of height/base

// Global settings
var canvas = document.getElementById("braingame");
var ctx = canvas.getContext('2d');
var start = null;						// Timestamp of first frame
var progress;							// Time elapsed in ms from first frame
var DEBUG = false;						// Debug 1 (mobs info & auto gate-trigger)
var DEBUG2 = false;						// Debug 2 (gate state)
var DEBUG3 = false;						// Debug3 (rules)
var DEBUG4 = false;						// Debug4 (3d mobs array)
var DEBUG5 = false;						// Debug5 (mobPause)
var memo = document.getElementById("memo");		// Text-box to display debug info
var memo2 = document.getElementById("memo2");		// Text-box#2 to display debug info
var memo3 = document.getElementById("memo3");		// Text-box#3 to display debug info
var memo4 = document.getElementById("memo4");		// Text-box#4 to display debug info
var memo5 = document.getElementById("memo5");		// Text-box#5 to display debug info
var scoreMemo = document.getElementById("score");		// Score box (temporary)
var score = 0;							// User 'score' ie correct choices
var strikes = 0;						// User 'strikes' ie incorrect choices
var maxStrikes = 3;						// Maximum strikes before game over
var level = 1;							// Game 'level' ie round ie wave etc etc etc etc

// Mobs constants
var mobs = [];							// Array of active moving objects
var mobCount = 0;							// Number of mob-groups created
var xSpeed = 300; 						// Object X speed in pixels per second
var mobMasterRadius = 25;				// Universal shape half-width
var originX = -mobMasterRadius; 		// X origin for shapes
var originY = canvas.height / 2;		// Y origin for shapes
var maxMobs = 3;						// Maximum number of mobs in a group
var minMobs = 1;						// Minimum number mobs in a group
var mobYSpacing = 10;					// Vertical spacing between mobs
// Time in MS (same unit as start/progress vars) for mob to completely traverse screen
var mobTransitTime = (canvas.width - originX + mobMasterRadius) / xSpeed * 1000;
var mobYVariance = 30;					// Pixels of Y oscillation (max)
var mobOscillations = 2.25;				// Number of complete sin oscillations 'wavy' mobs do, ie sin(0 to 2pi)
var mobFrequency = 1.5;					// Seconds between mob-groups
var mobPause = 0;						// 0 = mobs not paused. 1 = paused before rule-change. 2 = paused after
var mobPauseTimestamp = null;			// Timestamp for initiation of a mob-pause
var mobPauseDuration = 3;				// Seconds delay (for new mobs) before level-up
var mobPause2Duration = 2;			// Seconds delay after level-up

// Gate constants
var gateState = 0;						// 0 closed, 1 opening, 2 open, 3 closing
var gateSpeed = 0.3;					// Time in seconds it takes for gates to open or close
var gateDelay = 1.0;					// Time in seconds gates stay open before closing
var gateMax = 120/360*2*Math.PI;		// Max angle the gates will open (in radians)
// Length of entire gate-opening
var gateLength = maxMobs * (2 * mobMasterRadius + mobYSpacing) + 2.5 * mobMasterRadius;
var gateWidth = 15;						// Width of gate in pixels
var gateX = canvas.width - 1.25 * gateLength;	// Gate X position
var gateGap = 4;						// Gap between gate sections, in pixels(when closed)
var gateColour = "#000000";				// Colour of gate as CSS colour
var gateTimestamp = null;				// Timestamp for start of gate-open event
var gateDebug2;							// Var used with DEBUG2 to monitor gateState

// Rules constants
var rules = [];							// Array of current rules
var rulesMax = 3;						// Max number of rules
var rulesDuration = 10;					// Number of mob-groups the rules will apply to
var rulesY = 2*mobMasterRadius;			// Y position for rules (top)
var rulesX = gateX + gateLength/2 + 2*mobMasterRadius;		// X position for rules (left)
var rulesFontSize = 40;
var rulesFont = "arial";
var rulesNoWidth = 6;					// Line-width for the 'no' symbol
var rulesColour = "red";
var rulesNoSize = 1.5;					// How big the 'no' symbol for rules should be, vs mob-size
var rulesNoColour = "red";				// Colour for 'no' symbol
var rulesShapeColour = "black";			// Colour for rules shapes
var ruleShapePosMax = 1;				// Max number of must-have-this-shape rules
var ruleShapeNegMax = 1;				// Max number of must-not-have-this-shape rules
var ruleColourPosMax = 0;				// Max number of must-have-this-colour rules
var ruleColourNegMax = 2;				// Max number of must-not-have-this-colour rules

// Game Over
var gameOverFontColour = "red";
var gameOverFontSize = 180;				// Font-size in pixels
var gameOverFont = "arial";
var gameOverY = (canvas.height - gameOverFontSize) / 2 + gameOverFontSize;
var gameOverLineColour = "#ff9999";
var gameOverLineWidth = 3;

// Bad decision
var badWords = ["Bad!", "Oops!", "NO!", "OMG", "Huh", "Stahp", "Ugh", "Oh no!"];
var badCurrentWord = "bad";				// The current active badword
var badTimestamp;						// Timestamp for start of 'bad' event
var badFlag = false;					// Boolean to indicate an active 'bad' event
var badX;								// Bad X 
var badY;								// Bad Y 
var badFont = "arial";
var badFontSizeStart = 50;				// Initial bad font size
var badFontSizeEnd = 100;				// Ending bad font size
var badDuration = 0.75;					// "Bad" event duration in seconds
var badFontColour = "255,0,0";			// Font colour in comma-separated RGB

// good decision
var goodWords = ["Good!", "Boss!", "Sweet", "Great!", "Nice!", "OK!", "Killer!", "Woot!"];
var goodCurrentWord = "good";			// The current active goodword
var goodTimestamp;						// Timestamp for start of 'good' event
var goodFlag = false;					// Boolean to indicate an active 'good' event
var goodX;								// good X 
var goodY;								// good Y 
var goodFont = "arial";
var goodFontSizeStart = 40;				// Initial good font size
var goodFontSizeEnd = 80;				// Ending good font size
var goodDuration = 0.75;					// "good" event duration in seconds
var goodFontColour = "0,255,0";			// Font colour in comma-separated RGB


// Start the animation process
window.requestAnimationFrame(dFrame);


// dFrame draws one complete frame
function dFrame(timestamp) {
	if (!start) start = timestamp;
	progress = timestamp - start;
	ctx.clearRect(0, 0, canvas.width, canvas.height);

	// Stop new mob-creation for a few seconds before a new rule is introduced
	if (mobPause == 0 && Math.floor(mobCount / rulesDuration) + 1 != level) {
		mobPause = 1;
		if (DEBUG5) memo5.innerHTML += "mobPause = 1<br>\n";
	}
	
	// Restart mob creation after a mob-pause
	if (mobPause == 2 && progress - mobPauseTimestamp > mobPause2Duration * 1000) {
		mobPause = 0;
		if (DEBUG5) memo5.innerHTML += "mobPause = 0<br>\n";
		mobPauseTimestamp = null;
	}
	
	// Create new mobs
	if (mobPause == 0 && (mobs.length == 0 || 
			(mobs.length > 0 && progress - mobs[mobs.length-1][0][6] > mobFrequency * 1000))) {
		if (DEBUG4) memo4.innerHTML = "Creating new mobgroup:\n<br>";
		var r;
		var g;
		var b;
		var fillStyle;
		var strokeStyle;
		var numNewMobs = Math.floor(Math.random() * (maxMobs - minMobs + 1)) + minMobs;
		// mobGroupHeight is the distance from the centre of top mob to centre of bottom mob
		var mobGroupHeight = (numNewMobs - 1) * (mobYSpacing + 2 * mobMasterRadius);
		// memo.innerHTML = "";
		var mobGroup = [];			// Array of mobs for insertion into master 3d mobs array
		mobCount++;
		
		for (var looper = 0 ; looper < numNewMobs ; looper++ ) {
			if (DEBUG4) memo4.innerHTML += "Mob " + looper + "\n<br>";
			//Generate colours for fill style and line style
			r = Math.floor(Math.random() * 2);
			g = Math.floor(Math.random() * 2);
			b = Math.floor(Math.random() * 2);			
			fillStyle = "#" + (r?"ff":"00") + (g?"ff":"00") + (b?"ff":"00");
			strokeStyle = "#" + (r?"cc":"66") + (g?"cc":"66") + (b?"cc":"66");
			// Make pure-white into an off-white
			if (fillStyle == "#ffffff") {
				fillStyle = "#eeeeee";
				strokeStyle = "#cccccc";
			}
			// Insert new mob into array (1 shape)
			mobGroup.push([originX,originY - mobGroupHeight / 2 + looper * (2 * mobMasterRadius + mobYSpacing), Math.floor(Math.random() * 3), mobMasterRadius, fillStyle, strokeStyle, progress]);
		}
		// Insert new mob group into master mobs array
		if (DEBUG4) memo4.innerHTML += "mobGroup.length: " + mobGroup.length + "\n<br>";
		mobs.push(mobGroup);
		if (DEBUG4) memo4.innerHTML += "mobs.length: " + mobs.length + "\n<br>";
		
		// Display mob debug info
		if (DEBUG == true) {
			memo.innerHTML = "<br>\nActive mobs:<br>\n";
			for (var p = 0 ; p < mobs.length ; p++ ) {
				for (var q = 0 ; q < mobs[p].length ; q++ ) {
					for (var r = 0 ; r < mobs[p][q].length ; r++) {
						memo.innerHTML += mobs[p][q][r] + "  ";
					}
				}
				memo.innerHTML += "<br>\n";
			}
		}
	}


	// Draw the mobs
	for (var looper = 0 ; looper < mobs.length ; looper++) {
		for (var looper2 = 0 ; looper2 < mobs[looper].length ; looper2++) {
			var tempMob = mobs[looper][looper2];
			if (DEBUG4) memo4.innerHTML = "l1: " + looper + "  l2: " + looper2 + " tempMob: " + tempMob + "\n<br>";
			
			var mobX = tempMob[0] + (progress - tempMob[6]) / 1000 * xSpeed;  // X refresh		
			var mobY = tempMob[1] + Math.sin((progress - tempMob[6]) / mobTransitTime * endAngle * mobOscillations) * mobYVariance;
			var mobType = tempMob[2];
			var mobRad = tempMob[3];
			var mobFillStyle = tempMob[4];
			var mobLineStyle = tempMob[5];
			
			ctx.beginPath();

			switch (mobType) { 
				case 0: // Circle
				ctx.arc(mobX, mobY, mobRad, startAngle, endAngle);
				break;
				
				case 1: // Triangle
				ctx.moveTo(mobX - mobRad, mobY + mobRad * triRatio);
				ctx.lineTo(mobX + mobRad, mobY + mobRad * triRatio);
				ctx.lineTo(mobX, mobY - mobRad * triRatio);
				break;
				
				case 2: // Square
				ctx.rect(mobX - mobRad, mobY - mobRad, mobRad * 2, mobRad * 2);
				break;
			}
			
			ctx.fillStyle = mobFillStyle;		
			ctx.fill();
			ctx.lineWidth = 4;
			ctx.strokeStyle = mobLineStyle;
			ctx.stroke();
		}
	}

			
	// Draw the Gate
	
	// Top fence
	ctx.beginPath();
	ctx.moveTo(gateX - gateWidth/2, 0);
	ctx.lineTo(gateX - gateWidth/2, (canvas.height - gateLength) / 2);
	ctx.lineTo(gateX + gateWidth/2, (canvas.height - gateLength) / 2);
	ctx.lineTo(gateX + gateWidth/2, 0);
	ctx.fillStyle = gateColour;
	ctx.fill();
	
	// Bottom fence
	ctx.beginPath();
	ctx.moveTo(gateX - gateWidth/2, canvas.height);
	ctx.lineTo(gateX - gateWidth/2, canvas.height - (canvas.height - gateLength) / 2);
	ctx.lineTo(gateX + gateWidth/2, canvas.height - (canvas.height - gateLength) / 2);
	ctx.lineTo(gateX + gateWidth/2, canvas.height);
	ctx.fillStyle = gateColour;
	ctx.fill();
	
	// X and Y for upper gate-section's four-points
	var p1x;
	var p1y;
	var p2x;
	var p2y;
	var p3x;
	var p3y;
	var p4x;
	var p4y;		
	// X and Y for lower gate-section
	var p5x;
	var p5y;
	var p6x;
	var p6y;
	var p7x;
	var p7y;
	var p8x;
	var p8y;	

	var gateAngle = 0;
	
	//DEBUG
	if (0) {		// Auto-gate opening (dangerous early test)
		if (progress % 3000 < gateSpeed * 1000 && gateState == 0 && progress > 3000)
			gateState = 1;
	}
	//DEBUG2
	if (DEBUG2) {
		if (gateDebug2 == null) gateDebug2 = gateState;
		if (gateDebug2 != gateState) {
			memo2.innerHTML += "gateState changed to " + gateState + "<br>\n";
			gateDebug2 = gateState;
		}
	}
	
	switch (gateState) {
		case 0:		// Closed
			gateAngle = 0;
		break;
		
		case 1:		// Opening
			if (gateTimestamp == null || gateTimestamp == 0) {
				gateTimestamp = progress;
				if (DEBUG) memo2.innerHTML = "Gate timestamp: " + gateTimestamp;
			}
			gateAngle = (progress - gateTimestamp) / (gateSpeed * 1000) * gateMax;
			if (gateAngle > gateMax) {
				gateAngle = gateMax;
				gateState = 2;
			}
		break;
		
		case 2:		// Fully open
			gateAngle = gateMax;
			if (progress - gateTimestamp > (gateSpeed + gateDelay) * 1000) {
				gateState = 3;
			}
		break;
		
		case 3:		// Closing
			gateAngle = (gateSpeed * 1000 -(progress - (gateTimestamp + (gateSpeed + gateDelay) * 1000)))
				/ (gateSpeed * 1000) * gateMax;
			if (progress - gateTimestamp > (2 * gateSpeed + gateDelay) * 1000) {
				gateAngle = 0;
				gateState = 0;
				gateTimestamp = 0;
			}
		break;
	}

	// Set coords for gate vertices
	// Upper gate coords
	p1x = gateX + gateWidth/2;
	p1y = (canvas.height - gateLength) / 2;
	p2x = p1x - (- (gateLength - gateGap) / 2) * Math.sin(gateAngle);
	p2y = p1y - -(gateLength - gateGap) / 2 * Math.cos(gateAngle);	
	p3x = p1x + -gateWidth * Math.cos(gateAngle) - -(gateLength - gateGap) / 2 * Math.sin(gateAngle);
	p3y = p1y - (-gateWidth * Math.sin(gateAngle) + -(gateLength - gateGap) / 2 * Math.cos(gateAngle));
	p4x = p1x + -gateWidth * Math.cos(gateAngle);
	p4y = p1y - -gateWidth * Math.sin(gateAngle);
	
	// Lower gate coords
	p5x = gateX + gateWidth/2;
	p5y = canvas.height - (canvas.height - gateLength) / 2;
	p6x = p5x - (gateLength - gateGap) / 2 * Math.sin(-gateAngle);
	p6y = p5y + -(gateLength - gateGap) / 2 * Math.cos(-gateAngle);	
	p7x = p5x + -gateWidth * Math.cos(-gateAngle) -(gateLength - gateGap) / 2 * Math.sin(-gateAngle);
	p7y = p5y - (-gateWidth * Math.sin(-gateAngle) + (gateLength - gateGap) / 2 * Math.cos(-gateAngle));
	p8x = p5x + -gateWidth * Math.cos(-gateAngle);
	p8y = p5y - -gateWidth * Math.sin(-gateAngle);

	// Draw gate-sections
	// Top
	ctx.beginPath();
	ctx.moveTo(p1x, p1y);
	ctx.lineTo(p2x, p2y);
	ctx.lineTo(p3x, p3y);
	ctx.lineTo(p4x, p4y);
	ctx.fillStyle = gateColour;
	ctx.fill();	
	// Bottom
	ctx.beginPath();
	ctx.moveTo(p5x, p5y);
	ctx.lineTo(p6x, p6y);
	ctx.lineTo(p7x, p7y);
	ctx.lineTo(p8x, p8y);
	ctx.fillStyle = gateColour;
	ctx.fill();
	
	if (DEBUG3) {
	memo3.innerHTML = "mobCount = " + mobCount + "<br>\n";
	}

	
	// Determine rules
	// [0] rule type 0=shape 1=colour [1] 0=regular rule 1=NOT rule [2] shape-type (0-2 just like mobs array) [3] colour ie #ff0000
	if (rules.length == 0 || (mobPause == 1 && mobs.length == 0)) {	
		// old condition = (Math.floor(mobCount / rulesDuration) + 1 != level)
		level = Math.floor(mobCount / rulesDuration) + 1;
		levelScore();	// Refresh level & score
		if (rules.length > 0 ) {
			mobPauseTimestamp = progress;
			mobPause = 2;
			if (DEBUG5) memo5.innerHTML += "mobPause = 2<br>\n";
			}
		if (rules.length == rulesMax) {
			newRule();			// Doing it in this order prevents the same rule from being re-inserted
			rules.shift();		// Delete the oldest rule
		} else {
			newRule();
		}
		if (DEBUG3) {
		memo3.innerHTML += "Rule added<br>\n";
		memo3.innerHTML += rules.length + " rules.<br>\n";
		}
		if (rules.length >= 2) { // Increase min mobgroup size when there's more than 1 rule
			minMobs = 2;
		}
	}
	
	// Draw rules
	var rulesXcentre = rulesX + (canvas.width - rulesX) / 2;
	var rulesYstart = rulesY + rulesFontSize + mobMasterRadius * rulesNoSize + mobYSpacing
	ctx.fillStyle = rulesColour;
	ctx.font = rulesFontSize + "px " + rulesFont;
	ctx.fillText("RULES", rulesX, rulesY);
	for (var looper = 0 ; looper < rules.length ; looper++) {
		if (rules[looper][0] == 0) {	// Shape-rule
			drawRule(rules[looper][2], rulesXcentre, rulesYstart + looper * (2 * mobMasterRadius * rulesNoSize + mobYSpacing));
		} else {	// Colour-rule
			ctx.fillStyle = rules[looper][3];
			ctx.fillRect(rulesX, rulesYstart - mobMasterRadius * rulesNoSize + 
				looper * (2 * mobMasterRadius * rulesNoSize + mobYSpacing), canvas.width - rulesX,
				2 * mobMasterRadius * rulesNoSize);
		}
		if (rules[looper][1] == 1) {
			drawNo(rulesXcentre, rulesYstart + looper * (2 * mobMasterRadius * rulesNoSize + mobYSpacing),
				rules[looper][3] == "#ff0000" && rules[looper][0] == 1?"#ffffff":rulesNoColour);
		}
	}
	// drawNo(rulesXcentre, rulesYstart);
	
	
	// Draw any active 'bad' events
	if (badFlag) {
		ruleBad();
	}
	
		// Draw any active 'bad' events
	if (goodFlag) {
		ruleGood();
	}
	
			
	// Remove mobs that make it past gate
	if (mobs.length > 0 && timestamp - mobs[0][0][6] > (rulesX + mobMasterRadius) / xSpeed * 1000) {
		if (checkRule(mobs[0])) {
			ruleGood(rulesX, canvas.height/2);
		} else {
			ruleBad(rulesX, canvas.height/2);
		}
		mobs.shift();
	}
	// Kill mobs that hit closed gate
	while ( mobs.length > 0
		&& timestamp - mobs[0][0][6] > (gateX) / xSpeed * 1000 
		&& timestamp - mobs[0][0][6] < (gateX + mobMasterRadius) / xSpeed * 1000
		&&(gateState == 0 || gateState == 3)) {
		if (!checkRule(mobs[0])) {
			ruleGood(gateX, canvas.height/2);
		} else {
			ruleBad(gateX, canvas.height/2);
		}
		mobs.shift();
	}
	if (strikes < maxStrikes) {
		// gameOver(); 	// To test game-over text quickly
		window.requestAnimationFrame(dFrame);
	} else {
		gameOver();
	}
}

// Return a random colour (CMYK RGB or White)
function randStyle() {
	var r = Math.floor(Math.random() * 2);
	var g = Math.floor(Math.random() * 2);
	var b = Math.floor(Math.random() * 2);
	
	var fillStyle = "#" + (r?"ff":"00") + (g?"ff":"00") + (b?"ff":"00");
	var strokeStyle = "#" + (r?"ff":"33") + (g?"ff":"33") + (b?"ff":"33");
	
	if (fillStyle == "#ffffff") {
		fillStyle = "#eeeeee";
	}
	
	return fillStyle;
}

function openGate() {
	switch(gateState) {
	case 0:
		gateState = 1;
		break;
	case 1:
		// No action required
		break;
	case 2:
		// If gate is already open, reset timer 
		// gateTimestamp += ((progress - gateTimestamp) - gateSpeed * 1000);
		gateTimestamp = progress;
		if(DEBUG2)memo2.innerHTML += "GATE STAY-OPEN<br>\n";
		break;
	case 3:
		// If gate is closing, reverse direction and start opening
		gateTimestamp += (progress - gateTimestamp) - ((2 * gateSpeed + gateDelay) * 1000 - (progress - gateTimestamp));
		gateState = 1;
		if(DEBUG2)memo2.innerHTML += "GATE REOPEN<br>\n";
	
	}
}

function drawNo(noX, noY, noColour) {
	var noLineOffset = Math.sqrt(Math.pow(rulesNoSize * mobMasterRadius, 2) / 2);
	ctx.strokeStyle = noColour;
	ctx.lineWidth = rulesNoWidth;
	ctx.beginPath();
	ctx.arc(noX, noY, rulesNoSize * mobMasterRadius, 0, endAngle);
	ctx.moveTo(noX - noLineOffset, noY + noLineOffset);
	ctx.lineTo(noX + noLineOffset, noY - noLineOffset);
	ctx.stroke();
}

function drawRule(rType, rX, rY) {
	ctx.beginPath();

	switch (rType) { 
		case 0: // Circle
		ctx.arc(rX, rY, mobMasterRadius, startAngle, endAngle);
		break;
		
		case 1: // Triangle
		ctx.moveTo(rX - mobMasterRadius, rY + mobMasterRadius * triRatio);
		ctx.lineTo(rX + mobMasterRadius, rY + mobMasterRadius * triRatio);
		ctx.lineTo(rX, rY - mobMasterRadius * triRatio);
		ctx.closePath();
		break;
		
		case 2: // Square
		ctx.rect(rX - mobMasterRadius, rY - mobMasterRadius, mobMasterRadius * 2, mobMasterRadius * 2);
		break;
	}
	ctx.lineWidth = 4;
	ctx.strokeStyle = rulesShapeColour;
	ctx.stroke();
}

function checkRule(deadGroup) {
	var ruleFlags = new Array(rules.length);
	
	// Loop through all rule/mob combinations for the passed mob-group
	for (var rlooper = 0 ; rlooper < rules.length ; rlooper++) {
		for (var mlooper = 0 ; mlooper < deadGroup.length ; mlooper++ ) {
			if (rules[rlooper][1] == 0) {								// "Must-Have" rule
				if (rules[rlooper][0] == 0) {  		// Shape rule
					if (rules[rlooper][2] == deadGroup[mlooper][2]) {
						ruleFlags[rlooper] = true;
					}
				} else if (rules[rlooper][0] == 1) {	// Colour rule
					if (rules[rlooper][3] == deadGroup[mlooper][4]) {
						ruleFlags[rlooper] = true;
					}
				}
			} else {													// "NOT" rule
				if (rules[rlooper][0] == 0) {  		// Shape rule
					if (rules[rlooper][2] == deadGroup[mlooper][2]) {
						return false;
					}
				} else if (rules[rlooper][0] == 1) {	// Colour rule
					if (rules[rlooper][3] == deadGroup[mlooper][4]) {
						return false;
					}
				}
			}
		}
	}
	// Check to see if all "Must-Have" rules were met
	for (var looper = 0 ; looper < ruleFlags.length ; looper++ ) {
		if (ruleFlags[looper] != true && rules[looper][1] == 0) {
			return false;
		}
	}
	return true;	
}

// Draw an animated "good" message on screen for misses
function ruleGood(bX, bY) {
	levelScore();
	//scoreMemo.innerHTML += "Incorrect!!!<br>\n";
	if (goodFlag == false) {
		score++;
		goodFlag = true;
		goodTimestamp = progress;
		goodX = bX;
		goodY = bY;
		goodCurrentWord = goodWords[Math.floor(Math.random() * goodWords.length)];
	}
	
	if (arguments.length == 0) {
		bX = goodX;
		bY = goodY
	}
	
	if (goodFlag && progress - goodTimestamp < goodDuration * 1000) {
		var goodFontSize = Math.floor((progress - goodTimestamp) / (goodDuration * 1000) 
		* (goodFontSizeEnd - goodFontSizeStart) + goodFontSizeStart);
		var goodAlpha = (goodDuration * 1000 - (progress - goodTimestamp)) / (goodDuration * 1000);
		ctx.font = Math.floor(goodFontSize) + "px " + goodFont;
		ctx.fillStyle = "rgba(" + goodFontColour + ","+ goodAlpha + ")";
		ctx.fillText(goodCurrentWord, bX, bY + goodFontSize / 2);
	} else if (goodFlag && progress - goodTimestamp > goodDuration * 1000) {
		goodFlag = false;
	}
}


// Draw an animated "bad" message on screen for misses
function ruleBad(bX, bY) {
	levelScore();
	//scoreMemo.innerHTML += "Incorrect!!!<br>\n";
	if (badFlag == false) {
		strikes++;
		badFlag = true;
		badTimestamp = progress;
		badX = bX;
		badY = bY;
		badCurrentWord = badWords[Math.floor(Math.random() * badWords.length)];
	}
	
	if (arguments.length == 0) {
		bX = badX;
		bY = badY
	}
	
	if (badFlag && progress - badTimestamp < badDuration * 1000) {
		var badFontSize = Math.floor((progress - badTimestamp) / (badDuration * 1000) 
		* (badFontSizeEnd - badFontSizeStart) + badFontSizeStart);
		var badAlpha = (badDuration * 1000 - (progress - badTimestamp)) / (badDuration * 1000);
		ctx.font = Math.floor(badFontSize) + "px " + badFont;
		ctx.fillStyle = "rgba(" + badFontColour + ","+ badAlpha + ")";
		ctx.fillText(badCurrentWord, bX, bY + badFontSize / 2);
	} else if (badFlag && progress - badTimestamp > badDuration * 1000) {
		badFlag = false;
	}
}


function gameOver() {
	levelScore();
	// scoreMemo.innerHTML += "\n<br><h1>GAME OVER!</h1>";
	ctx.beginPath();
	ctx.fillStyle = gameOverFontColour;
	ctx.strokeStyle = gameOverLineColour;
	ctx.lineWidth = gameOverLineWidth;
	ctx.font = gameOverFontSize + "px " + gameOverFont;
	gameOverX = (canvas.width - ctx.measureText("Game Over").width) / 2;
	ctx.fillText("Game Over", gameOverX, gameOverY);
	ctx.strokeText("Game Over", gameOverX, gameOverY);
}

function levelScore() {
	scoreMemo.innerHTML = "Level " + level + "\n";
	scoreMemo.innerHTML += "<p>Score: " + score + "  Strikes: " + strikes + "<br>\n";
}

function newRule() {
	// Count up numbers of existing rule-types
	var shapePos = 0;
	var shapeNeg = 0;
	var colourPos = 0;
	var colourNeg = 0;
	for (var looper = 0 ; looper < rules.length ; looper++ ) {
		if (rules[looper][0] == 0) { 	// Shape rule
			if (rules[looper][1] == 0) { 	// Must-Have (positive) rule
				shapePos++;
			} else {						// NOT (negative) rule
				shapeNeg++;
			}
		} else {		// Colour rule
			if (rules[looper][1] == 0) { 	// Must-Have (positive) rule
				colourPos++;
			} else {						// NOT (negative) rule
				colourNeg++;
			}
		}
	}
	
	do {
	// Generate a new random rule
	var nRule = [Math.floor(Math.random() * 2), Math.floor(Math.random() * 2),Math.floor(Math.random() * 3), randStyle()];
	// If the new rule exceeds any of the rule-type maximums, re-roll it
	if (nRule[0] == 0 && nRule[1] == 0 && shapePos == ruleShapePosMax) continue;
	if (nRule[0] == 0 && nRule[1] == 1 && shapeNeg == ruleShapeNegMax) continue;
	if (nRule[0] == 1 && nRule[1] == 0 && colourPos == ruleColourPosMax) continue;
	if (nRule[0] == 1 && nRule[1] == 1 && colourNeg == ruleColourNegMax) continue;
	
	// Rule is not duplicate
	if (checkRuleDupe(nRule)) continue;
	// Rule does not contradict another rule
	if (checkRuleContradiction(nRule)) continue;
	
	rules.push(nRule);
	return;
	} while (1);
}

function checkRuleDupe(nR) {
	for (var looper = 0 ; looper < rules.length ; looper++) {
		if (nR[0] == rules[looper][0] && nR[1] == rules[looper][1]) {		// Type and polarity match
			if (nR[0] == 0 && nR[2] == rules[looper][2]) return true;		// Duplicate shape rule
			if (nR[0] == 1 && nR[3] == rules[looper][3]) return true;		// Duplicate colour rule
		}
	}
	return false;
}

// Fun fact: This function is identical to checkRuleDupe except for a single == becomes a !=
function checkRuleContradiction(nR) {
	for (var looper = 0 ; looper < rules.length ; looper++) {
		if (nR[0] == rules[looper][0] && nR[1] != rules[looper][1]) {		// Same type but opposite polarity
			if (nR[0] == 0 && nR[2] == rules[looper][2]) return true;		// Contradicting shape rule
			if (nR[0] == 1 && nR[3] == rules[looper][3]) return true;		// Contradicting colour rule
		}
	}
	return false;
}
</script>

</body>