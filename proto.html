<doctype html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Team Brain Train 5</title>
    <!-- JavaScript HTML requirements -->
    <link rel="stylesheet" href="https://code.jquery.com/mobile/1.2.0/jquery.mobile-1.2.0.min.css">
    <script src="https://code.jquery.com/jquery-1.8.2.min.js"></script>
    <script src="https://code.jquery.com/mobile/1.2.0/jquery.mobile-1.2.0.min.js"></script>
	
	<script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.9.22/paper-full.min.js"></script>

	<link rel="stylesheet" type="text/css" media="all" href="css/styles.css">
	<link rel="stylesheet" type="text/css" media="all" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/themes/base/jquery-ui.css">
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.10.3/jquery-ui.min.js"></script>

	<script type="text/javascript" src="paper-full.min.js"></script>
	
</head>
<body>
	
	<div data-role="page" id="menu">
		<canvas id="c" width=2000 height=2000></canvas>
		<div >
			<a href="#play"><img src="pngBtns/PlayBtn.png" class="menubtns" id="playbtn" /></a>
			<a href="#tutorial"><img src="pngBtns/TutorialBtn.png" class="menubtns" id="tutbtn" /></a>
			<a href="#leaderboard"><img src="pngBtns/LBBtn.png" class="menubtns" id="lbbtn" /></a>
			<a href="#options"><img src="pngBtns/OptionsBtn.png" class="menubtns" id="optionsbtn" /></a>
			<a href="#dialog-form" id="create-user"><img src="pngBtns/LoginBtn.png" class="menubtns" id="loginbtn" /></a>
			<div id="dialog-form" title="Create new user">
			  <form>
				<fieldset>
				  <label for="name">Name</label>
				  <input type="text" name="name" id="name" value="George Dung" class="text ui-widget-content ui-corner-all">
				  <label for="password">Password</label>
				  <input type="password" name="password" id="password" value="" class="text ui-widget-content ui-corner-all">
			 
				  <!-- form submission with enter key (doesn't work) -->
				  <!--<input type="submit" tabindex="-1" style="position:absolute; bottom:-1000px">-->
				</fieldset>
			  </form>
			</div>
		</div>
	</div>
	
	<div data-role="page" id="play">
		<canvas id = "braingame" width = 2000 height = 2000></canvas>
		<p><span id = "memo">Shape Escape v0.1</span>
		<p><span id = "score"></span>
		<p><span id = "memo2"></span>
		<p><span id = "memo3"></span>
		<p><span id = "memo4"></span>
		<p><span id = "memo5"></span>
		<audio preload="metadata" id="background" onloadeddata="setLowVolume()" autoplay loop> 
		<source src="sound/time.mp3">
		<div >
			<a href="#options"><img src="pngBtns/pauseBtn.png" id="pausebtn" /></a>
		</div>
		</audio>
		<script>
		// This function has to go in a separate script on this page due to the wacky way the Paper.JS
		// script has its own namespace. (therefore html elements can't call functions within it)  -Bri 
		function setLowVolume() {
			var myAudio = document.getElementById("background");  
			myAudio.volume = 1.0; //Changed this to 0.5 or 50% volume since the function is called Set Half Volume ;)
		}
		</script>
	</div>
	
	<div data-role="page" id="options">
		<a href="#" data-rel="back"><img src="pngBtns/BackBtn.png" class="menubtns backbtns" /></a>
		<canvas id="shapebg" width=2000 height=2000></canvas>
		<div class="pagestuff">
			<p class="ui-state-default ui-corner-all ui-helper-clearfix" style="padding:4px;">
			  <span class="ui-icon ui-icon-volume-on" style="float:left; margin:-2px 5px 0 0;"></span>
			  Master volume
			</p>
			
			<div id="master" style="width:260px; margin:15px;"></div>
			
			<p class="ui-state-default ui-corner-all ui-helper-clearfix" style="padding:4px;">
			  <span class="ui-icon ui-icon-volume-on" style="float:left; margin:-2px 5px 0 0;"></span>
			  BGM
			</p>
			
			<div id="bgm" style="width:260px; margin:15px;"></div>
			
			<p class="ui-state-default ui-corner-all ui-helper-clearfix" style="padding:4px;">
			  <span class="ui-icon ui-icon-volume-on" style="float:left; margin:-2px 5px 0 0;"></span>
			  SFX
			</p>
			
			<div id="sfx" style="width:260px; margin:15px;"></div>
			
			
		</div>
		<img id="teamlogo" src="LOGO_HI_RES.png" />
	</div>
	
	<div data-role="page" id="tutorial">
		<a href="#" data-rel="back"><img src="pngBtns/BackBtn.png" class="menubtns backbtns" /></a>
		<canvas id="shapebg2" width=2000 height=2000></canvas>
		<div class="pagestuff">
			
		</div>
	</div>
	
	<div data-role="page" id="leaderboard">
		<a href="#" data-rel="back"><img src="pngBtns/BackBtn.png" class="menubtns backbtns" /></a>
		<canvas id="shapebg3" width=2000 height=2000></canvas>
		<div class="pagestuff">
			<p><span id="lbname0"></span>
			<span id="lbscore0"></span>
			<p><span id="lbname1"></span>
			<span id="lbscore1"></span>
			<p><span id="lbname2"></span>
			<span id="lbscore2"></span>
			<p><span id="lbname3"></span>
			<span id="lbscore3"></span>
			<p><span id="lbname4"></span>
			<span id="lbscore4"></span>
			<p><span id="lbname5"></span>
			<span id="lbscore5"></span>
			<p><span id="lbname6"></span>
			<span id="lbscore6"></span>
			<p><span id="lbname7"></span>
			<span id="lbscore7"></span>
			<p><span id="lbname8"></span>
			<span id="lbscore8"></span>
			<p><span id="lbname9"></span>
			<span id="lbscore9"></span>
		</div>
		<script>
		
		$.getJSON("https://api.mongolab.com/api/1/databases/comp2910/collections/Leaderboard?apiKey=Vj5CySJu_PZcXUFihbe274Ty73YE9rHJ", function(data){
			var i = 0;
			var scoreArr = [0,0,0,0,0,0,0,0,0,0];
			var nameArr = ["", "", "", "", "", "", "", "", "", ""];
			$.each(data, function(index, value){
				var k = 0;
				for (k = 0 ; k < scoreArr.length ; k++){
					if (value.score >= scoreArr[k]){
						var temp = 0;
						for ( var z = scoreArr.length-1 ; z > k ; z--){
							scoreArr[z] = scoreArr[z-1];
							nameArr[z] = nameArr[z-1];
						}
						scoreArr[k] = value.score;
						nameArr[k] = value.name;
						k = 10;
					}
				}
			});
			var m = 0;
			for (m = 0 ; m < 10 ; m++){
				$("#lbname" + i).html(scoreArr[m]);
				$("#lbscore" + i).html(nameArr[m]);
				i++;
			}
			/*$('#tblLeaderBoard').append(html);*/
		});
		</script>
	</div>



<script type = "text/paperscript" canvas = "braingame">

// Constants
var startAngle = 0;
var endAngle = 2 * Math.PI;
var triRatio = 0.866; // Equilateral triangle ratio of height/base
// Global settings
var canvas = document.getElementById("braingame");
var ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
var start = null;						// Timestamp of first frame
var progress;							// Time elapsed in ms from first frame
var DEBUG = false;						// Debug 1 (mobs info & auto gate-trigger)
var DEBUG2 = false;						// Debug 2 (gate state)
var DEBUG3 = false;						// Debug3 (rules)
var DEBUG4 = false;						// Debug4 (3d mobs array)
var DEBUG5 = false;						// Debug5 (mobPause)
var DEBUG6 = false;						// Debug6 (Paper.js integration)
var DEBUG7 = false;						// Debug7 (game enhancement)
var memo = document.getElementById("memo");		// Text-box to display debug info
var memo2 = document.getElementById("memo2");		// Text-box#2 to display debug info
var memo3 = document.getElementById("memo3");		// Text-box#3 to display debug info
var memo4 = document.getElementById("memo4");		// Text-box#4 to display debug info
var memo5 = document.getElementById("memo5");		// Text-box#5 to display debug info
var scoreMemo = document.getElementById("score");		// Score box (temporary)
var score = 0;							// User 'score' ie correct choices
var strikes = 0;						// User 'strikes' ie incorrect choices
var maxStrikes = 3;						// Maximum strikes before game over
var level = 1;							// Game 'level' ie round ie wave etc etc etc etc
var timestamp;							// Time in milliseconds from game-start
//Menu Bar Constants
var barWidth = 50;
var barHeight = 60;
var barColor = "#fcef94";				//Fill Color
var barStrokeColor = "#000000";
//var level = 0;
//var score = 0;
//var strikes = 0;
// Mobs constants
var mobs = [];							// Array of active moving objects
var mobCount = 0;							// Number of mob-groups created
var xSpeed = 300; 						// Object X speed in pixels per second
var mobMasterRadius = 25;				// Universal shape half-width
var originX = -mobMasterRadius; 		// X origin for shapes
var originY = canvas.height / 2 + barHeight/2;		// Y origin for shapes
var maxMobs = 3;						// Maximum number of mobs in a group
var minMobs = 1;						// Minimum number mobs in a group
var mobYSpacing = 10;					// Vertical spacing between mobs
// Time in MS (same unit as start/progress vars) for mob to completely traverse screen
var mobTransitTime = (canvas.width - originX + mobMasterRadius) / xSpeed * 1000;
var mobYVariance = 30;					// Pixels of Y oscillation (max)
var mobOscillations = 2.25;				// Number of complete sin oscillations 'wavy' mobs do, ie sin(0 to 2pi)
var mobFrequency = 1.5;					// Seconds between mob-groups
var mobPause = 0;						// 0 = mobs not paused. 1 = paused before rule-change. 2 = paused after
var mobPauseTimestamp = null;			// Timestamp for initiation of a mob-pause
var mobPauseDuration = 3;				// Seconds delay (for new mobs) before level-up
var mobPause2Duration = 2;				// Seconds delay after level-up
var mobStarPoints = 5;					// Number of points stars have
var mobStrokeWidth = 2;					// Stroke width for moving shapes
var mobShapes = 5;						// Number of different types of shapes
var mobFills = ['#ff0000', '#00ff00', '#0000ff', '#ff00ff', '#ffff00'];		// Fill colours
var mobStrokes = ['#cc6666', '#66cc66', '#6666cc', '#cc66cc', '#cccc66'];	// Stroke colours
// Gate constants
var gateState = 0;						// 0 closed, 1 opening, 2 open, 3 closing
var gateSpeed = 0.3;					// Time in seconds it takes for gates to open or close
var gateDelay = 1.0;					// Time in seconds gates stay open before closing
var gateMax = 120/360*2*Math.PI;		// Max angle the gates will open (in radians)
// Length of entire gate-opening
var gateLength = maxMobs * (2 * mobMasterRadius + mobYSpacing) + 3.0 * mobMasterRadius;
var gateWidth = 10;						// Width of gate in pixels
var fenceWidth = 15;					// Width of fence (non-moving)
var gateX = canvas.width - 1.25 * gateLength;	// Gate X position
var gateGap = 4;						// Gap between gate sections, in pixels(when closed)
var gateColour = "#000000";				// Colour of gate as CSS colour
var gateStrokeColour = "#333333";		// Colour of gate outline
var gateTimestamp = null;				// Timestamp for start of gate-open event
var gateDebug2;							// Var used with DEBUG2 to monitor gateState
var gatePrevAngle = 0;					// A hacky way to get the gates to work with Paper.js...
// Rules constants
var rules = [];							// Array of current rules
var rulesMax = 3;						// Max number of rules
var rulesDuration = 10;					// Number of mob-groups the rules will apply to
var rulesY = 2*mobMasterRadius;			// Y position for rules (top)
var rulesX = gateX + gateLength/2 + 2*mobMasterRadius;		// X position for rules (left)
var rulesFontSize = 40;
var rulesFont = "arial";
var rulesNoWidth = 6;					// Line-width for the 'no' symbol
var rulesStrokeWidth = 4;				// Stroke-width for the rules shape
var rulesColour = "red";
var rulesNoSize = 1.5;					// How big the 'no' symbol for rules should be, vs mob-size
var rulesNoColour = "red";				// Colour for 'no' symbol
var rulesShapeColour = "black";			// Colour for rules shapes
var ruleShapePosMax = 1;				// Max number of must-have-this-shape rules
var ruleShapeNegMax = 2;				// Max number of must-not-have-this-shape rules
var ruleColourPosMax = 1;				// Max number of must-have-this-colour rules
var ruleColourNegMax = 2;				// Max number of must-not-have-this-colour rules
// Game Over
var gameOverFontColour = "red";
var gameOverFontSize = 180;				// Font-size in pixels
var gameOverFont = "arial";
// var gameOverY = (canvas.height - gameOverFontSize) / 2 + gameOverFontSize;
var gameOverY = 1.5 * gameOverFontSize;
var gameOverLineColour = "#ff9999";
var gameOverLineWidth = 3;
var lbFontSize = 50;					// Leaderboard font size
var lbLineWidth = 1;					// Leaderboard font stroke width	

// Bad decision
var badWords = ["Bad!", "Oops!", "NO!", "OMG", "Huh", "Stahp", "Ugh", "Oh no!"];
var badCurrentWord = "bad";				// The current active badword
var badTimestamp;						// Timestamp for start of 'bad' event
var badFlag = false;					// Boolean to indicate an active 'bad' event
var badX;								// Bad X 
var badY;								// Bad Y 
var badFont = "arial";
var badFontSizeStart = 50;				// Initial bad font size
var badFontSizeEnd = 100;				// Ending bad font size
var badDuration = 0.75;					// "Bad" event duration in seconds
var badFontColour = "255,0,0";			// Font colour in comma-separated RGB
var badPaperColour = '#ff0000';			// Font colour for Paper.js
var badPaper;							// Paper.js obj for 'bad' text
// good decision
var goodWords = ["Good!", "Boss!", "Sweet", "Great!", "Nice!", "OK!", 
	"Killer!", "Woot!", "Aaight", "Wow!", "Ooh", "Lovely!", "Superb", 
	"Tops!", "Rockin'", "Hoo-ah!", "Yes!", "Yeah!", "A+", "Bueno!", "Sugoi!"];
var goodCurrentWord = "good";			// The current active goodword
var goodTimestamp;						// Timestamp for start of 'good' event
var goodFlag = false;					// Boolean to indicate an active 'good' event
var goodX;								// good X 
var goodY;								// good Y 
var goodFont = "arial";
var goodFontSizeStart = 40;				// Initial good font size
var goodFontSizeEnd = 80;				// Ending good font size
var goodDuration = 0.75;				// "good" event duration in seconds
var goodFontColour = "0,255,0";			// Font colour in comma-separated RGB
var goodPaperColour = '#00ff00';		// Font colour for Paper.js
var goodPaper;							// Paper.js obj for 'good' text
var gameEnd = false;

// Achievements
var scoreStreak = 0;
var achScore = 4;						// Threshold for 'Score' achievement
var username = null;
var userpass = null;
var achCurrent; 						// The current active Achievement event
var achTimestamp;						// Timestamp for start of 'ach' event
var achFlag = false;					// Boolean to indicate an active 'ach' event
var achFont = "comic sans";
var achFontSizeStart = 80;				// Initial ach font size
var achFontSizeEnd = 300;				// Ending ach font size
var achDuration = 5;					// "Achievement" event duration in seconds
var achFontColour = "255,255,0";		// Font colour in comma-separated RGB
var achPaperColour = '#000000';			// Font colour for Paper.js
var achPaper;							// Paper.js obj for 'ach' text
var achMax = 1;							// Max number of achievements
var achFlags = new Array(achMax);		// Flags for achievements being completed

//VOLUME SLIDER
$(function() {
    // setup master volume
    $( "#master" ).slider({
      value: 100,
      orientation: "horizontal",
      range: "min",
      animate: true,
	  slide: function(event,ui) {
		background.volume = ui.value * 0.01;
	  }
    });
	$( "#bgm" ).slider({
      value: 100,
      orientation: "horizontal",
      range: "min",
      animate: true,
	  slide: function(event,ui) {
		background.volume = ui.value * 0.01;
	  }
    });
	$( "#sfx" ).slider({
      value: 100,
      orientation: "horizontal",
      range: "min",
      animate: true,
	  slide: function(event,ui) {
		
	  }
    });
  });
  
  //user login
    $(function() {
		var dialog, form,
	 
		  // From http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#e-mail-state-%28type=email%29
		  name = $( "#name" ),
		  password = $( "#password" ),
		  allFields = $( [] ).add( name ).add( password );
	 
	 
		function addUser() {
			allFields.removeClass( "ui-state-error" );
			username = name.val();
			userpass = password.val();
			dialog.dialog( "close" );
		}
	 
		dialog = $( "#dialog-form" ).dialog({
		  autoOpen: false,
		  height: 380,
		  width: 430,
		  modal: true,
		  show: {
			effect: "blind",
			duration: 300
		  },
		  hide: {
			effect: "explode",
			duration: 600
		  },
		  buttons: {
			"Submit": addUser,
			Cancel: function() {
			  dialog.dialog( "close" );
			}
		  },
		  close: function() {
			form[ 0 ].reset();
			allFields.removeClass( "ui-state-error" );
		  }
		});
	 
		form = dialog.find( "form" ).on( "submit", function( event ) {
		  event.preventDefault();
		  addUser();
		});
	 
		$( "#create-user" ).on( "click", function() {
		  dialog.dialog( "open" );
		});
	});


//Canvas resizing
/*(function() {
 
	// Start listening to resize events and
	// draw canvas.
	initialize();

	function initialize() {
		// Register an event listener to
		// call the resizeCanvas() function each time 
		// the window is resized.
		window.addEventListener('resize', resizeCanvas, false);
		
		resizeCanvas();
	}				

	// Runs each time the DOM window resize event fires.
	// Resets the canvas dimensions to match window,
	// then draws the new borders accordingly.
	function resizeCanvas() {
		//if(strikes < maxStrikes){
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
			//window.requestAnimationFrame(dFrame);
		//}
	}
})();*/
			
//Status Bar

var barGradient = {
		gradient: {
			stops: [["#ffffff", 0.01], ["#f1f1f1", 0.2], ["#555555", 1]],
			radial: false
		},
		origin: [0, 0],
		destination: [0, 50]
	};
	
new Path.Rectangle({
	point: [0,0],
	size: [canvas.width, barHeight],
	strokeColor: barStrokeColor,
	fillColor: barGradient			
});

var levelText = new PointText({
    point: [ 50, (barHeight + 12.5)/2],
    content: 'Level: ' + level,
    fillColor: 'black',
    fontFamily: 'Arial',
    fontWeight: 'bold',
    fontSize: 25
});

var scoreText = new PointText({
    point: [ 300, (barHeight + 12.5)/2],
    content: 'Score: ' + score,
    fillColor: 'black',
    fontFamily: 'Arial',
    fontWeight: 'bold',
    fontSize: 25
});

var strikesText = new PointText({
    point: [ 550, (barHeight + 12.5)/2],
    content: 'Strikes: ' + strikes,
    fillColor: 'black',
    fontFamily: 'Arial',
    fontWeight: 'bold',
    fontSize: 25
});

	var pausebutton = document.getElementById('pausebtn');
	pausebutton.style.position = "absolute";
	pausebutton.style.left = window.innerWidth - 100;
	pausebutton.style.top = window.innerHeight - (window.innerHeight - 5);
	
// Paper.js - Draw immobile fence pieces
new Path.Rectangle({
	point: [gateX - fenceWidth/2, 0 + barHeight],
	size: [fenceWidth, (canvas.height - gateLength) / 2 - barHeight ],
	strokeColor: gateStrokeColour,
	fillColor: gateColour
});
new Path.Rectangle({
	point: [gateX - fenceWidth/2, canvas.height - (canvas.height - gateLength) / 2],
	size: [fenceWidth, (canvas.height - gateLength) / 2],
	strokeColor: gateStrokeColour,
	fillColor: gateColour
});
// Paper.js - Draw movable gate pieces in initial positions
var topHinge = new Point(gateX + gateWidth/2, (canvas.height - gateLength) / 2);
var bottomHinge = new Point(gateX + gateWidth/2, canvas.height - (canvas.height - gateLength) / 2);
// Top
var topGate = new Path.Rectangle({
	from: topHinge,
	to: new Point(gateX - gateWidth/2, topHinge.y + (gateLength - gateGap) / 2),
	strokeColor: gateStrokeColour,
	fillColor: gateColour,
	center: topHinge
});
// Bottom
var bottomGate = new Path.Rectangle({
	from: bottomHinge,
	to: new Point(gateX - gateWidth/2, bottomHinge.y - (gateLength - gateGap) / 2),
	strokeColor: gateStrokeColour,
	fillColor: gateColour,
	center: bottomHinge
});
// Draw 'RULES'
new PointText({
	point: [rulesX, rulesY + barHeight],
	content: 'RULES',
	fontSize: rulesFontSize,
	fontFamily: rulesFont,
	fillColor: rulesColour
});
// Handle Paper.js click events
function onMouseDown(event) {
	openGate();
}
// onFrame draws one complete frame
function onFrame(event) {
	if (strikes < maxStrikes) {
		timestamp = event.time * 1000;
	}
	if (!start) start = timestamp;
	progress = timestamp - start;
	// Stop new mob-creation for a few seconds before a new rule is introduced
	if (mobPause == 0 && Math.floor(mobCount / rulesDuration) + 1 != level) {
		mobPause = 1;
		if (DEBUG5) memo5.innerHTML += "mobPause = 1<br>\n";
	}
	
	// Restart mob creation after a mob-pause
	if (mobPause == 2 && progress - mobPauseTimestamp > mobPause2Duration * 1000) {
		mobPause = 0;
		if (DEBUG5) memo5.innerHTML += "mobPause = 0<br>\n";
		mobPauseTimestamp = null;
	}
	
	
	if (DEBUG3) {
	memo3.innerHTML = "mobCount = " + mobCount + "<br>\n";
	}
	// Add a new rule
	// [0] rule type 0=shape 1=colour  [1] 0=regular rule 1=NOT rule  [2] shape-type (0-2 just like mobs array)
	// [3] colour ie #ff0000  [4] Array of Paper.js shape objects (1 shape and optionally 1 'not' symbol)
	if (rules.length == 0 || (mobPause == 1 && mobs.length == 0)) {
		if (DEBUG6) console.log('Add a new rule');
		// Update level
		level = Math.floor(mobCount / rulesDuration) + 1;
		levelScore();	// Refresh level & score
		if (rules.length > 0 ) {
			mobPauseTimestamp = progress;
			mobPause = 2;
			if (DEBUG5) memo5.innerHTML += "mobPause = 2<br>\n";
			}
		if (rules.length == rulesMax) {
			newRule();			// Doing it in this order prevents the same rule from being re-inserted
			paperDealloc(rules[0][4]);
			rules.shift();		// Delete the oldest rule
		} else {
			newRule();
		}
		if (DEBUG3) {
		memo3.innerHTML += "Rule added<br>\n";
		memo3.innerHTML += rules.length + " rules.<br>\n";
		}
		if (rules.length >= 2) { // Increase min mobgroup size when there's more than 1 rule
			minMobs = 2;
		}
		// Paper.js - redraw rules
		drawRuleSetPaper();
	}
	
	
	// Create new mobs
	if (mobPause == 0 && (mobs.length == 0 || 
			(mobs.length > 0 && progress - mobs[mobs.length-1][0][6] > mobFrequency * 1000))) {
		if (DEBUG4) memo4.innerHTML = "Creating new mobgroup:\n<br>";
		if (DEBUG4) memo4.innerHTML += "mobGroup.length: " + mobGroup.length + "\n<br>";
		
		// Decide whether the new mob group will comply with current rules or not (50/50 chance)
		var mobCompliant = makeMobGroup(Math.floor(Math.random() * 2) == 1 ? true : false);
		
		// Insert new mob group into master mobs array
		mobs.push(mobCompliant);
		if (DEBUG4) memo4.innerHTML += "mobs.length: " + mobs.length + "\n<br>";
		
		// Display mob debug info
		if (DEBUG == true) {
			memo.innerHTML = "<br>\nActive mobs:<br>\n";
			for (var p = 0 ; p < mobs.length ; p++ ) {
				for (var q = 0 ; q < mobs[p].length ; q++ ) {
					for (var r = 0 ; r < mobs[p][q].length ; r++) {
						memo.innerHTML += mobs[p][q][r] + "  ";
					}
				}
				memo.innerHTML += "<br>\n";
			}
		}
	}
	// Draw the mobs
	for (var looper = 0 ; looper < mobs.length ; looper++) {
		for (var looper2 = 0 ; looper2 < mobs[looper].length ; looper2++) {
			var tempMob = mobs[looper][looper2];
			if (DEBUG4) memo4.innerHTML = "l1: " + looper + "  l2: " + looper2 + " tempMob: " + tempMob + "\n<br>";
			
			var mobX = tempMob[0] + (progress - tempMob[6]) / 1000 * xSpeed;  // X refresh		
			var mobY = tempMob[1] + Math.sin((progress - tempMob[6]) / mobTransitTime * endAngle * mobOscillations) * mobYVariance;
			// Paper.js
			var mobPaperObj = tempMob[7];
			mobPaperObj.position.x = mobX;
			mobPaperObj.position.y = mobY;
		}
	}
	var gateAngle = 0;
	//DEBUG2
	if (DEBUG2) {
		if (gateDebug2 == null) gateDebug2 = gateState;
		if (gateDebug2 != gateState) {
			memo2.innerHTML += "gateState changed to " + gateState + "<br>\n";
			gateDebug2 = gateState;
		}
	}
	
	switch (gateState) {
		case 0:		// Closed
			gateAngle = 0;
		break;
		
		case 1:		// Opening
			if (gateTimestamp == null || gateTimestamp == 0) {
				gateTimestamp = progress;
				if (DEBUG) memo2.innerHTML = "Gate timestamp: " + gateTimestamp;
			}
			gateAngle = (progress - gateTimestamp) / (gateSpeed * 1000) * gateMax;
			if (gateAngle > gateMax) {
				gateAngle = gateMax;
				gateState = 2;
			}
		break;
		
		case 2:		// Fully open
			gateAngle = gateMax;
			if (progress - gateTimestamp > (gateSpeed + gateDelay) * 1000) {
				gateState = 3;
			}
		break;
		
		case 3:		// Closing
			gateAngle = (gateSpeed * 1000 -(progress - (gateTimestamp + (gateSpeed + gateDelay) * 1000)))
				/ (gateSpeed * 1000) * gateMax;
			if (progress - gateTimestamp > (2 * gateSpeed + gateDelay) * 1000) {
				gateAngle = 0;
				gateState = 0;
				gateTimestamp = 0;
			}
		break;
	}
	// Paper.js - a hacky way to make the old gate logic work with Paper
	if (gateAngle != gatePrevAngle) {
		var paperGateAngle = gateAngle - gatePrevAngle;
		gatePrevAngle = gateAngle;
	} else {
		var paperGateAngle = 0;
	}
	
	// Paper.js - Set rotation for gates
	topGate.rotate((-paperGateAngle / (2 * Math.PI)) * 360, topHinge);
	bottomGate.rotate((paperGateAngle / (2 * Math.PI)) * 360, bottomHinge);
	
	// Draw any active 'bad' events
	if (badFlag) {
		ruleBad();
	}
	
		// Draw any active 'bad' events
	if (goodFlag) {
		ruleGood();
	}
	
			// Draw any active achievement events
	if (achFlag) {
		achieveInit();
	}
			
	// Remove mobs that make it past gate
	if (mobs.length > 0 && timestamp - mobs[0][0][6] > (rulesX + mobMasterRadius) / xSpeed * 1000) {
		if (checkRule(mobs[0])) {
			ruleGood(rulesX, canvas.height/2);
		} else {
			ruleBad(rulesX, canvas.height/2);
		}
		// Paper.js - remove mob group from scene
		paperMobDealloc(mobs[0]);
		
		mobs.shift();
	}
	// Kill mobs that hit closed gate
	while ( mobs.length > 0
		&& timestamp - mobs[0][0][6] > (gateX) / xSpeed * 1000 
		&& timestamp - mobs[0][0][6] < (gateX + mobMasterRadius) / xSpeed * 1000
		&&(gateState == 0 || gateState == 3)) {
		if (!checkRule(mobs[0])) {
			ruleGood(gateX, canvas.height/2);
		} else {
			ruleBad(gateX, canvas.height/2);
		}
		// Paper.js - remove mob group from scene
		paperMobDealloc(mobs[0]);
		
		mobs.shift();
	}
	if (strikes < maxStrikes) {
		// gameOver(); 	// To test game-over text quickly
		// window.requestAnimationFrame(dFrame);
	} else {
		gameOver();
	}
}


// Make a new random mob-group that either complies or breaks the current rules, determined by
// boolean argument. TRUE = complies with rules, FALSE = breaks rules
function makeMobGroup(complies) {
		if (DEBUG7) console.log("makeMobGroup() - complies: " + complies + "\n");
		var r;
		var g;
		var b;
		var fillStyle;
		var strokeStyle;
		
		var numNewMobs = Math.floor(Math.random() * (maxMobs - minMobs + 1)) + minMobs;
		// mobGroupHeight is the distance from the centre of top mob to centre of bottom mob
		var mobGroupHeight = (numNewMobs - 1) * (mobYSpacing + 2 * mobMasterRadius);
		// memo.innerHTML = "";
		var mobGroup = [];			// Array of mobs for insertion into master 3d mobs array
		mobCount++;
		
		do {
			// wipe array and de-allocate its paper shapes from the scene
			for (var i = 0 ; i < mobGroup.length ; ) {
				mobGroup[i][7].remove();
				mobGroup.shift();
			}
			
			for (var looper = 0; looper < numNewMobs ; looper++ ) {
				if (DEBUG4) memo4.innerHTML += "Mob " + looper + "\n<br>";
				var mobShapeType = Math.floor(Math.random() * mobShapes);
				var originYInit = originY - mobGroupHeight / 2 + looper * (2 * mobMasterRadius + mobYSpacing);

				var mobColourIndex = Math.floor(Math.random() * mobFills.length);
				fillStyle = mobFills[mobColourIndex];
				strokeStyle = mobStrokes[mobColourIndex];
				
				// Paper.JS
				if (mobShapeType == 0) { 	// Circle
					var mobPaper = new Path.Circle({
						center: [originX, originYInit],
						radius: mobMasterRadius,
						strokeColor: strokeStyle,
						strokeWidth: mobStrokeWidth
					});
				} else if (mobShapeType == 1) { // Triangle
					var mobPaper = new Path.RegularPolygon({
						center: [originX, originYInit],
						sides: 3,
						radius: mobMasterRadius / Math.cos(Math.PI / 6),
						fillColor: fillStyle,
						strokeColor: strokeStyle,
						strokeWidth: mobStrokeWidth
					});
				} else if (mobShapeType == 2) { // Square
					var mobPaper = new Path.Rectangle({
						rectangle: new Rectangle(originX - mobMasterRadius, originYInit - mobMasterRadius, 2 * mobMasterRadius, 2 * mobMasterRadius),
						center: [originX, originYInit],
						fillColor: fillStyle,
						strokeColor: strokeStyle,
						strokeWidth: mobStrokeWidth
					});
				} else if (mobShapeType == 3) { // Pentagon
					var mobPaper = new Path.RegularPolygon({
						center: [originX, originYInit],
						sides: 5,
						radius: mobMasterRadius,
						fillColor: fillStyle,
						strokeColor: strokeStyle,
						strokeWidth: mobStrokeWidth
					});
				} else if (mobShapeType == 4) { // Star
					var mobPaper = new Path.Star({
						center: [originX, originYInit],
						radius1: mobMasterRadius,
						radius2: mobMasterRadius/2,
						points: mobStarPoints,
						fillColor: fillStyle,
						strokeColor: strokeStyle,
						strokeWidth: mobStrokeWidth
					});
				}
				
				// Set-up colour gradient on new shape object
				mobPaper.fillColor = {
						gradient: {
							stops: [[fillStyle, 0.05], [fillStyle, 0.2], [strokeStyle, 1]],
							radial: true
						},
						origin: mobPaper.position,
						destination: mobPaper.bounds.rightCenter
					};
					
				// Insert new mob into array (1 shape)
				mobGroup.push([originX, originYInit, mobShapeType, mobMasterRadius, fillStyle, strokeStyle, progress, mobPaper]);
			
				// If the newest shape added to the group makes the group non-compliant with
				// the desired outcome (specified by parameter) re-roll it.
				/*
				if (checkRule(mobGroup) != complies) {
					if (DEBUG7) console.log("complies: \n" + complies);
					mobGroup.pop();
					mobPaper.remove();
				} else {
					looper++;
				}
				*/
			}
		} while (checkRule(mobGroup) != complies);
		
	return mobGroup;
}


// Checks a mobGroup (array) to see if it complies with the current rules.
// Returns TRUE if group complies with all rules, FALSE otherwise.
function checkRule(deadGroup) {
	var ruleFlags = new Array(rules.length);
	if (DEBUG7) {
		console.log("checkRule(): rules0 - " + rules[0] + ", mob0 - " + deadGroup[0] + "\n");
		
	}
	
	// Loop through all rule/mob combinations for the passed mob-group
	for (var rlooper = 0 ; rlooper < rules.length ; rlooper++) {
		for (var mlooper = 0 ; mlooper < deadGroup.length ; mlooper++ ) {
			if (rules[rlooper][1] == 0) {								// "Must-Have" rule
				if (rules[rlooper][0] == 0) {  		// Shape rule
					if (rules[rlooper][2] == deadGroup[mlooper][2]) {
						ruleFlags[rlooper] = true;
					}
				} else if (rules[rlooper][0] == 1) {	// Colour rule
					if (rules[rlooper][3] == deadGroup[mlooper][4]) {
						ruleFlags[rlooper] = true;
					}
				}
			} else {													// "NOT" rule
				if (rules[rlooper][0] == 0) {  		// Shape rule
					if (rules[rlooper][2] == deadGroup[mlooper][2]) {
						return false;
					}
				} else if (rules[rlooper][0] == 1) {	// Colour rule
					if (rules[rlooper][3] == deadGroup[mlooper][4]) {
						return false;
					}
				}
			}
		}
	}
	// Check to see if all "Must-Have" rules were met
	for (var looper = 0 ; looper < ruleFlags.length ; looper++ ) {
		if (ruleFlags[looper] != true && rules[looper][1] == 0) {
			return false;
		}
	}
	return true;	
}


// Paper.js needs its own "draw rules" functions b/c it doesn't need to draw them per frame
function drawRuleSetPaper() {
	if (DEBUG6) console.log('drawRuleSetPaper()');
	var rulesXcentre = rulesX + (canvas.width - rulesX) / 2;
	var rulesYstart = rulesY + rulesFontSize + mobMasterRadius * rulesNoSize + mobYSpacing + barHeight/2
	
	// Clear out the old rule shapes
	for (var i = 0 ; i < rules.length ; i++) {
		if (rules[i][4].length > 0) {
			paperDealloc(rules[i][4]);
			rules[i][4] = [];
		}
	}
	
	for (var looper = 0 ; looper < rules.length ; looper++) {
		if (rules[looper][0] == 0) {	// Shape-rule
			rules[looper][4].push(drawPaperRule(rules[looper][2], rulesXcentre, rulesYstart + looper * (2 * mobMasterRadius * rulesNoSize + mobYSpacing)));
		} else {	// Colour-rule
			var rulesRect = new Path.Rectangle({
				point: [rulesX, rulesYstart - mobMasterRadius * rulesNoSize + looper * (2 * mobMasterRadius * rulesNoSize + mobYSpacing)],
				size: [canvas.width - rulesX, 2 * mobMasterRadius * rulesNoSize],
				fillColor: rules[looper][3]
			});
			rulesRect.sendToBack();
			rules[looper][4].push(rulesRect);
		}
		if (rules[looper][1] == 1) { 	// A reverse (Not) rule
			var newNo = drawNoPaper(rulesXcentre, rulesYstart + looper * (2 * mobMasterRadius * rulesNoSize + mobYSpacing),
				rules[looper][3] == "#ff0000" && rules[looper][0] == 1?"#ffffff":rulesNoColour);
			newNo.moveAbove(rules[looper][4][0]);
			rules[looper][4].push(newNo);
		}
	}
		if (DEBUG6) console.log('drawRuleSetPaper() - bottom');
}
// Paper.js - function to remove mob group from scene
function paperMobDealloc(deadGroup) {
	if (DEBUG6) console.log('paperMobDealloc()');
	for (var i = 0 ; i < deadGroup.length ; i++) {
		deadGroup[i][7].remove();
	}
}
// Paper.js - generic function to remove an array of objects from scene
function paperDealloc(deadGroup) {
	if (DEBUG6) console.log('paperDealloc()');
	for (var i = 0 ; i < deadGroup.length ; i++) {
		deadGroup[i].remove();
	}
}
// Return a random colour (CMYK RGB or White)
function randStyle() {
	var r = Math.floor(Math.random() * 2);
	var g = Math.floor(Math.random() * 2);
	var b = Math.floor(Math.random() * 2);
	
	var fillStyle = "#" + (r?"ff":"00") + (g?"ff":"00") + (b?"ff":"00");
	var strokeStyle = "#" + (r?"ff":"33") + (g?"ff":"33") + (b?"ff":"33");
	
	if (fillStyle == "#ffffff") {
		fillStyle = "#eeeeee";
	}
	
	return fillStyle;
}
function openGate() {
	switch(gateState) {
	case 0:
		gateState = 1;
		break;
	case 1:
		// No action required
		break;
	case 2:
		// If gate is already open, reset timer 
		// gateTimestamp += ((progress - gateTimestamp) - gateSpeed * 1000);
		gateTimestamp = progress;
		if(DEBUG2)memo2.innerHTML += "GATE STAY-OPEN<br>\n";
		break;
	case 3:
		// If gate is closing, reverse direction and start opening
		gateTimestamp += (progress - gateTimestamp) - ((2 * gateSpeed + gateDelay) * 1000 - (progress - gateTimestamp));
		gateState = 1;
		if(DEBUG2)memo2.innerHTML += "GATE REOPEN<br>\n";
	
	}
}
// Paper.js - Draw a 'No' over a rule
function drawNoPaper(noX, noY, noColour) {
	if (DEBUG6) console.log('drawNoPaper()');
	var noLineOffset = Math.sqrt(Math.pow(rulesNoSize * mobMasterRadius, 2) / 2);
	var noCircle = new Path.Circle({
		center: [noX, noY],
		radius: rulesNoSize * mobMasterRadius
	});
	var noLine = new Path.Line({
		from: [noX - noLineOffset, noY + noLineOffset],
		to: [noX + noLineOffset, noY - noLineOffset]
	});
	noCompound = new CompoundPath({
		strokeColor: noColour,
		strokeWidth: rulesNoWidth
	});
	noCompound.addChild(noCircle);
	noCompound.addChild(noLine);
	return noCompound;
}
// Paper.js - Separate rule-drawing function as it does not need to be drawn each frame
function drawPaperRule(rType, rX, rY) {
	if (DEBUG6) console.log('drawPaperRule()');
	switch (rType) { 
		case 0: // Circle
		var mobPaper = new Path.Circle({
				center: [rX, rY],
				radius: mobMasterRadius,
				strokeColor: rulesShapeColour,
				strokeWidth: rulesStrokeWidth
				});
		break;
		
		case 1: // Triangle
		// Paper.js
		var mobPaper = new Path.RegularPolygon({
			center: [rX, rY],
			sides: 3,
			radius: mobMasterRadius / Math.cos(Math.PI / 6),
			strokeColor: rulesShapeColour,
			strokeWidth: rulesStrokeWidth
		});
		break;
		
		case 2: // Square
		// Paper.js
		var mobPaper = new Path.Rectangle(new Rectangle(rX - mobMasterRadius, rY - mobMasterRadius, 2 * mobMasterRadius, 2 * mobMasterRadius));
				mobPaper.strokeColor = rulesShapeColour;	
				mobPaper.strokeWidth = rulesStrokeWidth;
		break;
		
		case 3: // Pentagon
			var mobPaper = new Path.RegularPolygon({
				center: [rX, rY],
				sides: 5,
				radius: mobMasterRadius,
				strokeColor: rulesShapeColour,
				strokeWidth: rulesStrokeWidth
			});
		break;
		
		case 4: // Star
			var mobPaper = new Path.Star({
				center: [rX, rY],
				radius1: mobMasterRadius,
				radius2: mobMasterRadius/2,
				points: mobStarPoints,
				strokeColor: rulesShapeColour,
				strokeWidth: rulesStrokeWidth
			});
		break;
	}
	mobPaper.sendToBack();
	return mobPaper;
}


// Draw an animated "good" message on screen for misses
function ruleGood(bX, bY) {
	//scoreStreak++;
	levelScore();
	var snd_good = new Audio("sound/chaching.mp3"); // hit sound
	if (goodFlag == false) {
		score++;
		goodFlag = true;
		goodTimestamp = progress;
		goodX = bX;
		goodY = bY;
		goodCurrentWord = goodWords[Math.floor(Math.random() * goodWords.length)];
		// Paper.js - create PointText object for text event
		goodPaper = new PointText(new Point(bX, bY));
		goodPaper.content = goodCurrentWord;
		goodPaper.fontSize = goodFontSizeStart;
		goodPaper.fontFamily = goodFont;
		goodPaper.fillColor = goodPaperColour;
		snd_good.play(); //"Good" choices
		
		// Kick-off a new score-streak achievement
		if (!achFlags[0] && ++scoreStreak == achScore) {
			achieveInit("Score");
		}
		
		/*if(scoreStreak >= 20) {
			$.ajax( { url: "https://api.mongolab.com/api/1/databases/comp2910/collections/Achievements?apiKey=Vj5CySJu_PZcXUFihbe274Ty73YE9rHJ",
			  data: JSON.stringify( { "name" : username , "password" : userpass, "achieveReached" : achievenums } ),
			  type: "POST",
			  contentType: "application/json" } );
		}*/
		
		// George - put your sound-effect code here for "Good" choices
		// meh.
		
	}
	
	if (arguments.length == 0) {
		bX = goodX;
		bY = goodY
	}
	
	if (goodFlag && progress - goodTimestamp < goodDuration * 1000) {
		var goodFontSize = Math.floor((progress - goodTimestamp) / (goodDuration * 1000) 
		* (goodFontSizeEnd - goodFontSizeStart) + goodFontSizeStart);
		var goodAlpha = (goodDuration * 1000 - (progress - goodTimestamp)) / (goodDuration * 1000);
		
		// Paper.js - scale & alpha font object
		goodPaper.scaling = goodFontSize / goodFontSizeStart;
		goodPaper.opacity =  goodAlpha;
	} else if (goodFlag && progress - goodTimestamp > goodDuration * 1000) {
		goodFlag = false;
		goodPaper.remove();
	}
}
// Draw an animated "bad" message on screen for misses
function ruleBad(bX, bY) {
	levelScore();
	var snd_bad = new Audio("sound/doh.mp3"); //miss sound
	//scoreMemo.innerHTML += "Incorrect!!!<br>\n";
	if (badFlag == false) {
		scoreStreak = 0;
		strikes++;
		badFlag = true;
		badTimestamp = progress;
		badX = bX;
		badY = bY;
		badCurrentWord = badWords[Math.floor(Math.random() * badWords.length)];
		// Paper.js - create PointText object for text event
		badPaper = new PointText(new Point(bX, bY));
		badPaper.content = badCurrentWord;
		badPaper.fontSize = badFontSizeStart;
		badPaper.fontFamily = badFont;
		badPaper.fillColor = badPaperColour;
		snd_bad.play(); //"Bad" choices
		
		// George - put your sound-effect code here for "Bad" choices
		
	}
	
	if (arguments.length == 0) {
		bX = badX;
		bY = badY
	}
	
	if (badFlag && progress - badTimestamp < badDuration * 1000) {
		var badFontSize = Math.floor((progress - badTimestamp) / (badDuration * 1000) 
		* (badFontSizeEnd - badFontSizeStart) + badFontSizeStart);
		var badAlpha = (badDuration * 1000 - (progress - badTimestamp)) / (badDuration * 1000);
		// Paper.js - scale & alpha font object
		badPaper.scaling = badFontSize / badFontSizeStart;
		badPaper.opacity =  badAlpha;
	} else if (badFlag && progress - badTimestamp > badDuration * 1000) {
		badFlag = false;
		badPaper.remove();
	}
}


function achieveInit(aType) {
	levelScore();
	var snd_ach = new Audio("sound/foghorn.mp3"); //miss sound

	if (achFlag == false) {
		switch (aType) {
			case "Score":
				achCurrent = achScore + " - Streak!";
				achFlags[0] = true;
				break;
			case "hiscore":
				achCurrent = "New High Score!";
				break;
		}
		achFlag = true;
		achTimestamp = progress;
		achX = 0;
		achY = canvas.height;
		// Paper.js - create PointText object for text event
		achPaper = new PointText(new Point(achX, achY));
		achPaper.content = achCurrent;
		achPaper.fontSize = achFontSizeStart;
		achPaper.fontFamily = achFont;
		achPaper.fillColor = achPaperColour;
		snd_ach.play(); //"Bad" choices		
	}
	
	if (arguments.length == 0) {
		// No action required
	}
	if (achFlag && progress - achTimestamp < achDuration * 1000) {
		var achFontSize = Math.floor((progress - achTimestamp) / (achDuration * 1000) 
		* (achFontSizeEnd - achFontSizeStart) + achFontSizeStart);
		var achAlpha = (achDuration * 1000 - (progress - achTimestamp)) / (achDuration * 1000);
		// Paper.js - scale & alpha font object
		achPaper.scaling = achFontSize / achFontSizeStart;
		achPaper.opacity =  achAlpha;
		achPaper.point.y = canvas.height;
		achPaper.point.x = 0;
	} else if (achFlag && progress - achTimestamp > achDuration * 1000) {
		achFlag = false;
		achPaper.remove();
	}
}

function gameOver() {
	levelScore();
	var snd_gameover = new Audio("sound/disappointed.mp3");  //game over sound
	
	if(gameEnd == false){
		// Big "Game Over" text
		var gameOverText = new PointText({
			point: [0, gameOverY],
			content: 'Game Over',
			fontSize: gameOverFontSize,
			fontFamily: gameOverFont,
			fillColor: gameOverFontColour,
			strokeColor: gameOverLineColour,
			strokeWidth: gameOverLineWidth
		});
		gameOverText.point.x = (canvas.width - gameOverText.bounds.width) / 2;

			snd_gameover.play();//game over sound
			$.ajax( { url: "https://api.mongolab.com/api/1/databases/comp2910/collections/Leaderboard?apiKey=Vj5CySJu_PZcXUFihbe274Ty73YE9rHJ",
			  data: JSON.stringify( { "name" : username , "score" : score } ),
			  type: "POST",
			  contentType: "application/json" } );
			gameEnd = true;
			
			// Ajax query to pull top-scores
			$.getJSON("https://api.mongolab.com/api/1/databases/comp2910/collections/Leaderboard?apiKey=Vj5CySJu_PZcXUFihbe274Ty73YE9rHJ", function(data){
				var i = 0;
				var scoreArr = [0,0,0,0,0,0,0,0,0,0];
				var nameArr = ["", "", "", "", "", "", "", "", "", ""];
				$.each(data, function(index, value){
					var k = 0;
					for (k = 0 ; k < scoreArr.length ; k++){
						if (value.score >= scoreArr[k]){
							var temp = 0;
							for ( var z = scoreArr.length-1 ; z > k ; z--){
								scoreArr[z] = scoreArr[z-1];
								nameArr[z] = nameArr[z-1];
							}
							scoreArr[k] = value.score;
							nameArr[k] = value.name;
							k = 10;
						}
					}
				});
				
			new PointText({
				point: [gameOverText.point.x, gameOverY + lbFontSize * 1.5],
				content: "Top Five:",
				fontSize: lbFontSize,
				fontFamily: gameOverFont,
				fillColor: gameOverFontColour,
				strokeColor: gameOverLineColour,
				strokeWidth: lbLineWidth + 1
			});		
			
			var m = 0;
			for (m = 0 ; m < 5 ; m++){
				// $("#lbname" + i).html(scoreArr[m]);
				// $("#lbscore" + i).html(nameArr[m]);
				new PointText({
					point: [gameOverText.point.x, gameOverY + 2 * lbFontSize * 1.5 + m * (lbFontSize * 1.5)],
					content: scoreArr[m] + " - " + nameArr[m],
					fontSize: lbFontSize,
					fontFamily: gameOverFont,
					fillColor: gameOverFontColour,
					strokeColor: gameOverLineColour,
					strokeWidth: lbLineWidth
				});					
				
				i++;
			}
			/*$('#tblLeaderBoard').append(html);*/
		});			

	}
	document.getElementById('background').pause();
	document.getElementById('background').currentTime = 0; //stops the music
	
}
function levelScore() {
levelText.remove();
levelText = new PointText({
    point: [ 50, (barHeight + 12.5)/2],
    content: 'Level: ' + level,
    fillColor: 'black',
    fontFamily: 'Arial',
    fontWeight: 'bold',
    fontSize: 25
});
scoreText.remove();
scoreText = new PointText({
    point: [ 300, (barHeight + 12.5)/2],
    content: 'Score: ' + score,
    fillColor: 'black',
    fontFamily: 'Arial',
    fontWeight: 'bold',
    fontSize: 25
});
strikesText.remove();
strikesText = new PointText({
    point: [ 550, (barHeight + 12.5)/2],
    content: 'Strikes: ' + strikes,
    fillColor: 'black',
    fontFamily: 'Arial',
    fontWeight: 'bold',
    fontSize: 25
});
}
function newRule() {
	// Count up numbers of existing rule-types
	var shapePos = 0;
	var shapeNeg = 0;
	var colourPos = 0;
	var colourNeg = 0;
	for (var looper = 0 ; looper < rules.length ; looper++ ) {
		if (rules[looper][0] == 0) { 	// Shape rule
			if (rules[looper][1] == 0) { 	// Must-Have (positive) rule
				shapePos++;
			} else {						// NOT (negative) rule
				shapeNeg++;
			}
		} else {		// Colour rule
			if (rules[looper][1] == 0) { 	// Must-Have (positive) rule
				colourPos++;
			} else {						// NOT (negative) rule
				colourNeg++;
			}
		}
	}
	
	do {
	// Generate a new random rule
	var nRule = [Math.floor(Math.random() * 2), Math.floor(Math.random() * 2),Math.floor(Math.random() * mobShapes), mobFills[Math.floor(Math.random() * mobFills.length)], []];
	// If the new rule exceeds any of the rule-type maximums, re-roll it
	if (nRule[0] == 0 && nRule[1] == 0 && shapePos == ruleShapePosMax) continue;
	if (nRule[0] == 0 && nRule[1] == 1 && shapeNeg == ruleShapeNegMax) continue;
	if (nRule[0] == 1 && nRule[1] == 0 && colourPos == ruleColourPosMax) continue;
	if (nRule[0] == 1 && nRule[1] == 1 && colourNeg == ruleColourNegMax) continue;
	
	// Rule is not duplicate
	if (checkRuleDupe(nRule)) continue;
	// Rule does not contradict another rule
	if (checkRuleContradiction(nRule)) continue;
	
	rules.push(nRule);
	return;
	} while (1);
}
function checkRuleDupe(nR) {
	for (var looper = 0 ; looper < rules.length ; looper++) {
		if (nR[0] == rules[looper][0] && nR[1] == rules[looper][1]) {		// Type and polarity match
			if (nR[0] == 0 && nR[2] == rules[looper][2]) return true;		// Duplicate shape rule
			if (nR[0] == 1 && nR[3] == rules[looper][3]) return true;		// Duplicate colour rule
		}
	}
	return false;
}
// Fun fact: This function is identical to checkRuleDupe except for a single == becomes a !=
function checkRuleContradiction(nR) {
	for (var looper = 0 ; looper < rules.length ; looper++) {
		if (nR[0] == rules[looper][0] && nR[1] != rules[looper][1]) {		// Same type but opposite polarity
			if (nR[0] == 0 && nR[2] == rules[looper][2]) return true;		// Contradicting shape rule
			if (nR[0] == 1 && nR[3] == rules[looper][3]) return true;		// Contradicting colour rule
		}
	}
	return false;
}


</script>
<!-- main menu script-->
<script type = "text/paperscript" canvas = "c">


//button positioning
	var playbutton = document.getElementById('playbtn');
	playbutton.style.position = "absolute";
	playbutton.style.left = window.innerWidth / 2 - 149.5;
	playbutton.style.top = window.innerHeight / 2 - 48.5;
	var tutbutton = document.getElementById('tutbtn');
	tutbutton.style.position = "absolute";
	tutbutton.style.left = window.innerWidth / 2 - 127.5;
	tutbutton.style.top = window.innerHeight / 2 + 51.5;
	var lbbutton = document.getElementById('lbbtn');
	lbbutton.style.position = "absolute";
	lbbutton.style.left = window.innerWidth / 2 - 127.5;
	lbbutton.style.top = window.innerHeight / 2 + 135.5;
	var optnbutton = document.getElementById('optionsbtn');
	optnbutton.style.position = "absolute";
	optnbutton.style.left = window.innerWidth / 2 - 40;
	optnbutton.style.top = window.innerHeight / 2 + 219.5;
	var backbutton = document.getElementsByClassName('backbtns');
	var i;
	for(i = 0; i < backbutton.length; i++){
		var temp = backbutton[i];
		temp.style.position = "absolute";
		temp.style.left = 10;
		temp.style.top = 10;
	}
	var userbutton = document.getElementById('create-user');
	userbutton.style.position = "absolute";
	userbutton.style.left = window.innerWidth / 2 + 40;
	userbutton.style.top = window.innerHeight / 2 + 219.5;
	
	
	//button hover functions
	$(function() {
		$("img.menubtns")
			.mouseover(function() { 
				var src = $(this).attr("src").match(/[^\.]+/) + "Over.png";
				$(this).attr("src", src);
			})
			.mouseout(function() {
				var src = $(this).attr("src").replace("Over.png", ".png");
				$(this).attr("src", src);
			});
	});
	
	//main menu resizing
	var canvas = document.getElementById("c");
	var ctx = canvas.getContext('2d');
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	
	//document.getElementById("c").style.background = 'white';
	// The amount of circles we want to make:
	var count = window.innerWidth/15;

	// Create a symbol, which we will use to place instances of later:
	var pathCircle = new Path.Circle({
		center: [0, 0],
		radius: 40,
		fillColor: 'black',
		strokeColor: 'grey'
	});
	var pathSquare = new Path.Rectangle({
		point: [0, 0],
		size: [35, 35],
		fillColor: 'black',
		strokeColor: 'grey'
	});
	var pathTriangle = new Path.RegularPolygon({
		center: [0, 0],
		sides: 3,
		radius: 40,
		fillColor: 'black',
		strokeColor: 'grey'
	});
	var pathPentagon = new Path.RegularPolygon({
		center: [0, 0],
		sides: 5,
		radius: 40,
		fillColor: 'black',
		strokeColor: 'grey'
	});
	var pathStar = new Path.Star({
		center: [50, 50],
		points: 5,
		radius1: 40,
		radius2: -40,
		fillColor: 'black',
		strokeColor: 'grey'
	});
	
	//var symbol = new Symbol(path);

	// Place the instances of the symbol:
	for (var i = 0; i < count; i++) {
		if(i % 2 == 0){
			var symbol = new Symbol(pathCircle);
		}
		if(i % 5 == 0){
			var symbol = new Symbol(pathSquare);
		}
		if(i % 7 == 0){
			var symbol = new Symbol(pathTriangle);
		}
		if(i % 4 == 0){
			var symbol = new Symbol(pathPentagon);
		}
		if(i % 9 == 0){
			var symbol = new Symbol(pathStar);
		}
		// The center position is a random point in the view:
		var center = Point.random() * screen.width;
		var placedSymbol = symbol.place(center);
		placedSymbol.scale(i / count);
	}
	
	//title
	var xPos = window.innerWidth/3.1;
	var yPos = window.innerHeight/4;
	var vec_speed = 30;
	var letter_color = 'white';
	var letter_font = ["tahoma"];
	var letter_weight = 'bold';
	var letter_size = 100;
	var letter_scale = 2;
	var s_letter1 = new PointText({
		point: [xPos, yPos],
		content: 'S',
		fillColor: letter_color,
		fontFamily: letter_font,
		fontWeight: letter_weight,
		fontSize: letter_size,
		scale: letter_scale
	});
	var h_letter = new PointText({
		point: [xPos+30*letter_scale, yPos],
		content: 'H',
		fillColor: letter_color,
		fontFamily: letter_font,
		fontWeight: letter_weight,
		fontSize: letter_size,
		scale: letter_scale
	});
	var a_letter1 = new PointText({
		point: [xPos+65*letter_scale, yPos],
		content: 'A',
		fillColor: letter_color,
		fontFamily: letter_font,
		fontWeight: letter_weight,
		fontSize: letter_size,
		scale: letter_scale
	});
	var p_letter1 = new PointText({
		point: [xPos+95*letter_scale, yPos],
		content: 'P',
		fillColor: letter_color,
		fontFamily: letter_font,
		fontWeight: letter_weight,
		fontSize: letter_size,
		scale: letter_scale
	});
	var e_letter1 = new PointText({
		point: [xPos+125*letter_scale, yPos],
		content: 'E',
		fillColor: letter_color,
		fontFamily: letter_font,
		fontWeight: letter_weight,
		fontSize: letter_size,
		scale: letter_scale
	});
	var e_letter2 = new PointText({
		point: [xPos+170*letter_scale, yPos],
		content: 'E',
		fillColor: letter_color,
		fontFamily: letter_font,
		fontWeight: letter_weight,
		fontSize: letter_size,
		scale: letter_scale
	});
	var s_letter2 = new PointText({
		point: [xPos+200*letter_scale, yPos],
		content: 'S',
		fillColor: letter_color,
		fontFamily: letter_font,
		fontWeight: letter_weight,
		fontSize: letter_size,
		scale: letter_scale
	});
	var c_letter = new PointText({
		point: [xPos+230*letter_scale, yPos],
		content: 'C',
		fillColor: letter_color,
		fontFamily: letter_font,
		fontWeight: letter_weight,
		fontSize: letter_size,
		scale: letter_scale
	});
	var a_letter2 = new PointText({
		point: [xPos+265*letter_scale, yPos],
		content: 'A',
		fillColor: letter_color,
		fontFamily: letter_font,
		fontWeight: letter_weight,
		fontSize: letter_size,
		scale: letter_scale
	});
	var p_letter2 = new PointText({
		point: [xPos+300*letter_scale, yPos],
		content: 'P',
		fillColor: letter_color,
		fontFamily: letter_font,
		fontWeight: letter_weight,
		fontSize: letter_size,
		scale: letter_scale
	});
	var e_letter3 = new PointText({
		point: [xPos+330*letter_scale, yPos],
		content: 'E',
		fillColor: letter_color,
		fontFamily: letter_font,
		fontWeight: letter_weight,
		fontSize: letter_size,
		scale: letter_scale
	});
	var letter_s1 = new Group({children: [s_letter1]});
	var dest_s_letter1 = s_letter1.position;
	letter_s1.position = [c.width-1000, c.height+200];

	var letter_h = new Group({children: [h_letter]});
	var dest_h_letter = h_letter.position;
	letter_h.position = [c.width-800, c.height+200];

	var letter_a1 = new Group({children: [a_letter1]});
	var dest_a_letter1 = a_letter1.position;
	letter_a1.position = [c.width-600, c.height+200];

	var letter_p1 = new Group({children: [p_letter1]});
	var dest_p_letter1 = p_letter1.position;
	letter_p1.position = [c.width-400, c.height+200];

	var letter_e1 = new Group({children: [e_letter1]});
	var dest_e_letter1 = e_letter1.position;
	letter_e1.position = [c.width-300, c.height+200];

	var letter_e2 = new Group({children: [e_letter2]});
	var dest_e_letter2 = e_letter2.position;
	letter_e2.position = [c.width-1000, c.height-1600];

	var letter_s2 = new Group({children: [s_letter2]});
	var dest_s_letter2 = s_letter2.position;
	letter_s2.position = [c.width-900, c.height-1600];

	var letter_c = new Group({children: [c_letter]});
	var dest_c_letter = c_letter.position;
	letter_c.position = [c.width-800, c.height-1600];

	var letter_a2 = new Group({children: [a_letter2]});
	var dest_a_letter2 = a_letter2.position;
	letter_a2.position = [c.width-700, c.height-1600];

	var letter_p2 = new Group({children: [p_letter2]});
	var dest_p_letter2 = p_letter2.position;
	letter_p2.position = [c.width-600, c.height-1600];

	var letter_e3 = new Group({children: [e_letter3]});
	var dest_e_letter3 = e_letter3.position;
	letter_e3.position = [c.width-500, c.height-1600];

	/*	
	function nextFont() {
		var count = -1;
		return function() {
			return letter_font[++count % letter_font.length];
		}
	}*/

	// The onFrame function is called up to 60 times a second:
	function onFrame(event) {
	
	// Run through the active layer's children list and change
		// the position of the placed symbols:
		for (var i = 0; i < count; i++) {
			var item = project.activeLayer.children[i];
			
			// Move the item 1/20th of its width to the right. This way
			// larger circles move faster than smaller circles:
			item.position.x += item.bounds.width / 100;

			// If the item has left the view on the right, move it back
			// to the left:
			if (item.bounds.left > view.size.width) {
				item.position.x = -item.bounds.width;
			}
		}
		
		//Title
		var vector1 = dest_s_letter1 - letter_s1.position;
		letter_s1.position+=vector1/vec_speed;
		letter_s1.content = Math.round(vector1.length);
		
		var vector2 = dest_h_letter - letter_h.position;
		letter_h.position+=vector2/vec_speed;
		letter_h.content = Math.round(vector2.length);
		
		var vector3 = dest_a_letter1 - letter_a1.position;
		letter_a1.position+=vector3/vec_speed;
		letter_a1.content = Math.round(vector3.length);
		
		var vector4 = dest_p_letter1 - letter_p1.position;
		letter_p1.position+=vector4/vec_speed;
		letter_p1.content = Math.round(vector4.length);
		
		var vector5 = dest_e_letter1 - letter_e1.position;
		letter_e1.position+=vector5/vec_speed;
		letter_e1.content = Math.round(vector5.length);
		
		var vector6 = dest_e_letter2 - letter_e2.position;
		letter_e2.position+=vector6/vec_speed;
		letter_e2.content = Math.round(vector6.length);
		
		var vector7 = dest_s_letter2 - letter_s2.position;
		letter_s2.position+=vector7/vec_speed;
		letter_s2.content = Math.round(vector7.length);
		
		var vector8 = dest_c_letter - letter_c.position;
		letter_c.position+=vector8/vec_speed;
		letter_c.content = Math.round(vector8.length);
		
		var vector9 = dest_a_letter2 - letter_a2.position;
		letter_a2.position+=vector9/vec_speed;
		letter_a2.content = Math.round(vector9.length);
		
		var vector10 = dest_p_letter2 - letter_p2.position;
		letter_p2.position+=vector10/vec_speed;
		letter_p2.content = Math.round(vector10.length);
		
		var vector11 = dest_e_letter3 - letter_e3.position;
		letter_e3.position+=vector11/vec_speed;
		letter_e3.content = Math.round(vector11.length);
		
		letter_s1.fillColor = new Color(Math.random(), Math.random(), Math.random());
		letter_h.fillColor = new Color(Math.random(), Math.random(), Math.random());
		letter_a1.fillColor = new Color(Math.random(), Math.random(), Math.random());
		letter_p1.fillColor = new Color(Math.random(), Math.random(), Math.random());
		letter_e1.fillColor = new Color(Math.random(), Math.random(), Math.random());
		letter_e2.fillColor = new Color(Math.random(), Math.random(), Math.random());
		letter_s2.fillColor = new Color(Math.random(), Math.random(), Math.random());
		letter_c.fillColor = new Color(Math.random(), Math.random(), Math.random());
		letter_a2.fillColor = new Color(Math.random(), Math.random(), Math.random());
		letter_p2.fillColor = new Color(Math.random(), Math.random(), Math.random());
		letter_e3.fillColor = new Color(Math.random(), Math.random(), Math.random());
	}
	

	
	
</script>

<script type = "text/paperscript" canvas = "shapebg">
	
	//main menu resizing
	var canvas = document.getElementById("shapebg");
	var ctx = canvas.getContext('2d');
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	
	//document.getElementById("c").style.background = 'white';
	// The amount of circles we want to make:
	var count = window.innerWidth/15;

	// Create a symbol, which we will use to place instances of later:
	var pathCircle = new Path.Circle({
		center: [0, 0],
		radius: 40,
		fillColor: 'black',
		strokeColor: 'grey'
	});
	var pathSquare = new Path.Rectangle({
		point: [0, 0],
		size: [35, 35],
		fillColor: 'black',
		strokeColor: 'grey'
	});
	var pathTriangle = new Path.RegularPolygon({
		center: [0, 0],
		sides: 3,
		radius: 40,
		fillColor: 'black',
		strokeColor: 'grey'
	});
	var pathPentagon = new Path.RegularPolygon({
		center: [0, 0],
		sides: 5,
		radius: 40,
		fillColor: 'black',
		strokeColor: 'grey'
	});
	var pathStar = new Path.Star({
		center: [50, 50],
		points: 5,
		radius1: 40,
		radius2: -40,
		fillColor: 'black',
		strokeColor: 'grey'
	});
	
	//var symbol = new Symbol(path);

	// Place the instances of the symbol:
	for (var i = 0; i < count; i++) {
		if(i % 2 == 0){
			var symbol = new Symbol(pathCircle);
		}
		if(i % 5 == 0){
			var symbol = new Symbol(pathSquare);
		}
		if(i % 7 == 0){
			var symbol = new Symbol(pathTriangle);
		}
		if(i % 4 == 0){
			var symbol = new Symbol(pathPentagon);
		}
		if(i % 9 == 0){
			var symbol = new Symbol(pathStar);
		}
		// The center position is a random point in the view:
		var center = Point.random() * screen.width;
		var placedSymbol = symbol.place(center);
		placedSymbol.scale(i / count);
	}

	// The onFrame function is called up to 60 times a second:
	function onFrame(event) {
	
	// Run through the active layer's children list and change
		// the position of the placed symbols:
		for (var i = 0; i < count; i++) {
			var item = project.activeLayer.children[i];
			
			// Move the item 1/20th of its width to the right. This way
			// larger circles move faster than smaller circles:
			item.position.x += item.bounds.width / 100;

			// If the item has left the view on the right, move it back
			// to the left:
			if (item.bounds.left > view.size.width) {
				item.position.x = -item.bounds.width;
			}
		}
	}
</script>

<script type = "text/paperscript" canvas = "shapebg2">
	
	//main menu resizing
	var canvas = document.getElementById("shapebg2");
	var ctx = canvas.getContext('2d');
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	
	//document.getElementById("c").style.background = 'white';
	// The amount of circles we want to make:
	var count = window.innerWidth/15;

	// Create a symbol, which we will use to place instances of later:
	var pathCircle = new Path.Circle({
		center: [0, 0],
		radius: 40,
		fillColor: 'black',
		strokeColor: 'grey'
	});
	var pathSquare = new Path.Rectangle({
		point: [0, 0],
		size: [35, 35],
		fillColor: 'black',
		strokeColor: 'grey'
	});
	var pathTriangle = new Path.RegularPolygon({
		center: [0, 0],
		sides: 3,
		radius: 40,
		fillColor: 'black',
		strokeColor: 'grey'
	});
	var pathPentagon = new Path.RegularPolygon({
		center: [0, 0],
		sides: 5,
		radius: 40,
		fillColor: 'black',
		strokeColor: 'grey'
	});
	var pathStar = new Path.Star({
		center: [50, 50],
		points: 5,
		radius1: 40,
		radius2: -40,
		fillColor: 'black',
		strokeColor: 'grey'
	});
	
	//var symbol = new Symbol(path);

	// Place the instances of the symbol:
	for (var i = 0; i < count; i++) {
		if(i % 2 == 0){
			var symbol = new Symbol(pathCircle);
		}
		if(i % 5 == 0){
			var symbol = new Symbol(pathSquare);
		}
		if(i % 7 == 0){
			var symbol = new Symbol(pathTriangle);
		}
		if(i % 4 == 0){
			var symbol = new Symbol(pathPentagon);
		}
		if(i % 9 == 0){
			var symbol = new Symbol(pathStar);
		}
		// The center position is a random point in the view:
		var center = Point.random() * screen.width;
		var placedSymbol = symbol.place(center);
		placedSymbol.scale(i / count);
	}

	// The onFrame function is called up to 60 times a second:
	function onFrame(event) {
	
	// Run through the active layer's children list and change
		// the position of the placed symbols:
		for (var i = 0; i < count; i++) {
			var item = project.activeLayer.children[i];
			
			// Move the item 1/20th of its width to the right. This way
			// larger circles move faster than smaller circles:
			item.position.x += item.bounds.width / 100;

			// If the item has left the view on the right, move it back
			// to the left:
			if (item.bounds.left > view.size.width) {
				item.position.x = -item.bounds.width;
			}
		}
	}
</script>

<script type = "text/paperscript" canvas = "shapebg3">
	
	//main menu resizing
	var canvas = document.getElementById("shapebg3");
	var ctx = canvas.getContext('2d');
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	
	//document.getElementById("c").style.background = 'white';
	// The amount of circles we want to make:
	var count = window.innerWidth/15;

	// Create a symbol, which we will use to place instances of later:
	var pathCircle = new Path.Circle({
		center: [0, 0],
		radius: 40,
		fillColor: 'black',
		strokeColor: 'grey'
	});
	var pathSquare = new Path.Rectangle({
		point: [0, 0],
		size: [35, 35],
		fillColor: 'black',
		strokeColor: 'grey'
	});
	var pathTriangle = new Path.RegularPolygon({
		center: [0, 0],
		sides: 3,
		radius: 40,
		fillColor: 'black',
		strokeColor: 'grey'
	});
	var pathPentagon = new Path.RegularPolygon({
		center: [0, 0],
		sides: 5,
		radius: 40,
		fillColor: 'black',
		strokeColor: 'grey'
	});
	var pathStar = new Path.Star({
		center: [50, 50],
		points: 5,
		radius1: 40,
		radius2: -40,
		fillColor: 'black',
		strokeColor: 'grey'
	});
	
	//var symbol = new Symbol(path);

	// Place the instances of the symbol:
	for (var i = 0; i < count; i++) {
		if(i % 2 == 0){
			var symbol = new Symbol(pathCircle);
		}
		if(i % 5 == 0){
			var symbol = new Symbol(pathSquare);
		}
		if(i % 7 == 0){
			var symbol = new Symbol(pathTriangle);
		}
		if(i % 4 == 0){
			var symbol = new Symbol(pathPentagon);
		}
		if(i % 9 == 0){
			var symbol = new Symbol(pathStar);
		}
		// The center position is a random point in the view:
		var center = Point.random() * screen.width;
		var placedSymbol = symbol.place(center);
		placedSymbol.scale(i / count);
	}

	// The onFrame function is called up to 60 times a second:
	function onFrame(event) {
	
	// Run through the active layer's children list and change
		// the position of the placed symbols:
		for (var i = 0; i < count; i++) {
			var item = project.activeLayer.children[i];
			
			// Move the item 1/20th of its width to the right. This way
			// larger circles move faster than smaller circles:
			item.position.x += item.bounds.width / 100;

			// If the item has left the view on the right, move it back
			// to the left:
			if (item.bounds.left > view.size.width) {
				item.position.x = -item.bounds.width;
			}
		}
	}
</script>

</body>